<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mir_eval Documentation &mdash; mir_eval 0.3 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="mir_eval 0.3 documentation" href="#" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">mir_eval 0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="mir-eval-documentation">
<h1><code class="docutils literal"><span class="pre">mir_eval</span></code> Documentation<a class="headerlink" href="#mir-eval-documentation" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">mir_eval</span></code> is a Python library which provides a transparent, standaridized, and straightforward way to evaluate Music Information Retrieval systems.
It can be used in any of the following ways:</p>
<ul class="simple">
<li>By importing it and calling it from your Python code (see <a class="reference internal" href="#installation"><span>Installing mir_eval</span></a> and <a class="reference internal" href="#mir-eval-quickstart"><span>Quickstart: Using mir_eval in Python code</span></a>)</li>
<li>Via the included evaluator Python scripts (see <a class="reference internal" href="#installation"><span>Installing mir_eval</span></a> and <a class="reference internal" href="#evaluators"><span>Quickstart: Using the evaluators</span></a>)</li>
</ul>
<p>If you use <code class="docutils literal"><span class="pre">mir_eval</span></code> in a research project, please cite the following paper:</p>
<ol class="upperalpha simple" start="3">
<li>Raffel, B. McFee, E. J. Humphrey, J. Salamon, O. Nieto, D. Liang, and D. P. W. Ellis, <a class="reference external" href="http://colinraffel.com/publications/ismir2014mir_eval.pdf">&#8220;mir_eval: A Transparent Implementation of Common MIR Metrics&#8221;</a>, Proceedings of the 15th International Conference on Music Information Retrieval, 2014.</li>
</ol>
<div class="section" id="installing-mir-eval">
<span id="installation"></span><h2>Installing <code class="docutils literal"><span class="pre">mir_eval</span></code><a class="headerlink" href="#installing-mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The simplest way to install <code class="docutils literal"><span class="pre">mir_eval</span></code> is by using <code class="docutils literal"><span class="pre">pip</span></code>, which will also install the required dependencies if needed.
To install <code class="docutils literal"><span class="pre">mir_eval</span></code> using <code class="docutils literal"><span class="pre">pip</span></code>, simply run</p>
<p><code class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">mir_eval</span></code></p>
<p>Alternatively, you can install <code class="docutils literal"><span class="pre">mir_eval</span></code> from source by first installing the dependencies and then running</p>
<p><code class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code></p>
<p>from the source directory.</p>
<p>If you don&#8217;t use Python and want to get started as quickly as possible, you might consider using <a class="reference external" href="https://store.continuum.io/cshop/anaconda/">Anaconda</a> which makes it easy to install a Python environment which can run <code class="docutils literal"><span class="pre">mir_eval</span></code>.</p>
</div>
<div class="section" id="quickstart-using-the-evaluators">
<span id="evaluators"></span><h2>Quickstart: Using the evaluators<a class="headerlink" href="#quickstart-using-the-evaluators" title="Permalink to this headline">¶</a></h2>
<p>The fastest way to get up and running with <code class="docutils literal"><span class="pre">mir_eval</span></code> is to use the evaluators.
These are scripts which can be run from the command line and utilize <code class="docutils literal"><span class="pre">mir_eval</span></code> to compute metrics according to reference and estimated annotations you provide.
To use the evaluators, you must first install <code class="docutils literal"><span class="pre">mir_eval</span></code> and its dependencies (see <a class="reference internal" href="#installation"><span>Installing mir_eval</span></a>).
The evaluator Python scripts can be found in the <code class="docutils literal"><span class="pre">mir_eval</span></code> github repository in the <code class="docutils literal"><span class="pre">evaluators</span></code> folder:</p>
<p><a class="reference external" href="http://github.com/craffel/mir_eval/tree/master/evaluators">http://github.com/craffel/mir_eval/tree/master/evaluators</a></p>
<p>One evaluator is included for each of the MIR tasks implemented in <code class="docutils literal"><span class="pre">mir_eval</span></code>.
By way of example, we&#8217;ll cover the usage of the beat detection evaluator <code class="docutils literal"><span class="pre">beat_eval</span></code>.
To use an evaluator for a different task, simply replace <code class="docutils literal"><span class="pre">beat_eval</span></code> in the following with the name of the evaluator for the task you&#8217;re interested in.
To get usage help, simply run</p>
<p><code class="docutils literal"><span class="pre">./beat_eval.py</span> <span class="pre">--help</span></code></p>
<p>As an example, to evaluate generated beat times stored in the file <code class="docutils literal"><span class="pre">estimated_beats.txt</span></code> against ground-truth beats stored in the file <code class="docutils literal"><span class="pre">reference_beats.txt</span></code> and store the resulting scores in <code class="docutils literal"><span class="pre">results.json</span></code>, simply run</p>
<p><code class="docutils literal"><span class="pre">./beat_eval.py</span> <span class="pre">-o</span> <span class="pre">results.json</span> <span class="pre">reference_beats.txt</span> <span class="pre">estimated_beats.txt</span></code></p>
<p>The file <code class="docutils literal"><span class="pre">results.json</span></code> will now contain the achieved scores in machine-parsable, human-readable json format.  Nice!</p>
</div>
<div class="section" id="quickstart-using-mir-eval-in-python-code">
<span id="mir-eval-quickstart"></span><h2>Quickstart: Using <code class="docutils literal"><span class="pre">mir_eval</span></code> in Python code<a class="headerlink" href="#quickstart-using-mir-eval-in-python-code" title="Permalink to this headline">¶</a></h2>
<p>Once you&#8217;ve installed <code class="docutils literal"><span class="pre">mir_eval</span></code> (see <a class="reference internal" href="#installation"><span>Installing mir_eval</span></a>), you can import it in your Python code as follows:</p>
<p><code class="docutils literal"><span class="pre">import</span> <span class="pre">mir_eval</span></code></p>
<p>From here, you will typically either load in data and call the <code class="docutils literal"><span class="pre">evaluate()</span></code> function from the appropriate submodule like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c1"># Scores will be a dict containing scores for all of the metrics</span>
<span class="c1"># implemented in mir_eval.beat.  The keys are metric names</span>
<span class="c1"># and values are the scores achieved</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>or you&#8217;ll load in the data, do some preprocessing, and call specific metric functions from the appropriate submodule like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c1"># Crop out beats before 5s, a common preprocessing step</span>
<span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="c1"># Compute the F-measure metric and store it in f_measure</span>
<span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>The documentation for each metric function, found in the <a class="reference internal" href="#mir-eval"><span>mir_eval</span></a> section below, contains further usage information.</p>
</div>
<div class="section" id="mir-eval">
<span id="id1"></span><h2><code class="docutils literal"><span class="pre">mir_eval</span></code><a class="headerlink" href="#mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The structure of the <code class="docutils literal"><span class="pre">mir_eval</span></code> Python module is as follows:
Each MIR task for which evaluation metrics are included in <code class="docutils literal"><span class="pre">mir_eval</span></code> is given its own submodule, and each metric is defined as a separate function in each submodule.
Every metric function includes detailed documentation, example usage, input validation, and references to the original paper which defined the metric (see the subsections below).
The task submodules also all contain a function <code class="docutils literal"><span class="pre">evaluate()</span></code>, which takes as input reference and estimated annotations and returns a dictionary of scores for all of the metrics implemented (for casual users, this is the place to start).
Finally, each task submodule also includes functions for common data pre-processing steps.</p>
<p><code class="docutils literal"><span class="pre">mir_eval</span></code> also includes the following additional submodules:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">io</span></code> which contains convenience functions for loading in task-specific data from common file formats</li>
<li><code class="docutils literal"><span class="pre">util</span></code> which includes miscellaneous functionality shared across the submodules</li>
<li><code class="docutils literal"><span class="pre">sonify</span></code> which implements some simple methods for synthesizing annotations of various formats for &#8220;evaluation by ear&#8221;.</li>
</ul>
<p>The following subsections document each submodule.</p>
<div class="section" id="module-mir_eval.beat">
<span id="mir-eval-beat"></span><h3><a class="reference internal" href="#module-mir_eval.beat" title="mir_eval.beat"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.beat</span></code></a><a class="headerlink" href="#module-mir_eval.beat" title="Permalink to this headline">¶</a></h3>
<p>The aim of a beat detection algorithm is to report the times at which a typical
human listener might tap their foot to a piece of music. As a result, most
metrics for evaluating the performance of beat tracking systems involve
computing the error between the estimated beat times and some reference list of
beat locations. Many metrics additionally compare the beat sequences at
different metric levels in order to deal with the ambiguity of tempo.</p>
<dl class="docutils">
<dt>Based on the methods described in:</dt>
<dd>Matthew E. P. Davies,  Norberto Degara, and Mark D. Plumbley.
&#8220;Evaluation Methods for Musical Audio Beat Tracking Algorithms&#8221;,
Queen Mary University of London Technical Report C4DM-TR-09-06
London, United Kingdom, 8 October 2009.</dd>
<dt>See also the Beat Evaluation Toolbox:</dt>
<dd><a class="reference external" href="https://code.soundsoftware.ac.uk/projects/beat-evaluation/">https://code.soundsoftware.ac.uk/projects/beat-evaluation/</a></dd>
</dl>
<div class="section" id="conventions">
<h4>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h4>
<p>Beat times should be provided in the form of a 1-dimensional array of beat
times in seconds in increasing order.  Typically, any beats which occur before
5s are ignored; this can be accomplished using
<a class="reference internal" href="#mir_eval.beat.trim_beats" title="mir_eval.beat.trim_beats"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.trim_beats()</span></code></a>.</p>
</div>
<div class="section" id="metrics">
<h4>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.beat.f_measure" title="mir_eval.beat.f_measure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.f_measure()</span></code></a>: The F-measure of the beat sequence, where an
estimated beat is considered correct if it is sufficiently close to a
reference beat</li>
<li><a class="reference internal" href="#mir_eval.beat.cemgil" title="mir_eval.beat.cemgil"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.cemgil()</span></code></a>: Cemgil&#8217;s score, which computes the sum of
Gaussian errors for each beat</li>
<li><a class="reference internal" href="#mir_eval.beat.goto" title="mir_eval.beat.goto"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.goto()</span></code></a>: Goto&#8217;s score, a binary score which is 1 when at
least 25% of the estimated beat sequence closely matches the reference beat
sequence</li>
<li><a class="reference internal" href="#mir_eval.beat.p_score" title="mir_eval.beat.p_score"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.p_score()</span></code></a>: McKinney&#8217;s P-score, which computes the
cross-correlation of the estimated and reference beat sequences represented
as impulse trains</li>
<li><a class="reference internal" href="#mir_eval.beat.continuity" title="mir_eval.beat.continuity"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.continuity()</span></code></a>: Continuity-based scores which compute the
proportion of the beat sequence which is continuously correct</li>
<li><a class="reference internal" href="#mir_eval.beat.information_gain" title="mir_eval.beat.information_gain"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.information_gain()</span></code></a>: The Information Gain of a normalized
beat error histogram over a uniform distribution</li>
</ul>
<dl class="function">
<dt id="mir_eval.beat.trim_beats">
<code class="descclassname">mir_eval.beat.</code><code class="descname">trim_beats</code><span class="sig-paren">(</span><em>beats</em>, <em>min_beat_time=5.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.trim_beats" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes beats before min_beat_time.  A common preprocessing step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beats</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of beat times in seconds.</p>
</div></blockquote>
<p><strong>min_beat_time</strong> : float</p>
<blockquote>
<div><p>Minimum beat time to allow
(Default value = 5.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>beats_trimmed</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Trimmed beat array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.validate">
<code class="descclassname">mir_eval.beat.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid beat time
arrays, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>estimated beat times, in seconds</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.f_measure">
<code class="descclassname">mir_eval.beat.</code><code class="descname">f_measure</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>f_measure_threshold=0.07</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted beats.
&#8220;Correctness&#8221; is determined over a small window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>estimated beat times, in seconds</p>
</div></blockquote>
<p><strong>f_measure_threshold</strong> : float</p>
<blockquote>
<div><p>Window size, in seconds
(Default value = 0.07)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_score</strong> : float</p>
<blockquote class="last">
<div><p>The computed F-measure score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                        estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.cemgil">
<code class="descclassname">mir_eval.beat.</code><code class="descname">cemgil</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>cemgil_sigma=0.04</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.cemgil" title="Permalink to this definition">¶</a></dt>
<dd><p>Cemgil&#8217;s score, computes a gaussian error of each estimated beat.
Compares against the original beat times and all metrical variations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>cemgil_sigma</strong> : float</p>
<blockquote>
<div><p>Sigma parameter of gaussian error windows
(Default value = 0.04)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cemgil_score</strong> : float</p>
<blockquote>
<div><p>Cemgil&#8217;s score for the original reference beats</p>
</div></blockquote>
<p><strong>cemgil_max</strong> : float</p>
<blockquote class="last">
<div><p>The best Cemgil score for all metrical variations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cemgil_score</span><span class="p">,</span> <span class="n">cemgil_max</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">cemgil</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                    estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.goto">
<code class="descclassname">mir_eval.beat.</code><code class="descname">goto</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>goto_threshold=0.35</em>, <em>goto_mu=0.2</em>, <em>goto_sigma=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.goto" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Goto&#8217;s score, a binary 1 or 0 depending on some specific
heuristic criteria</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>goto_threshold</strong> : float</p>
<blockquote>
<div><p>Threshold of beat error for a beat to be &#8220;correct&#8221;
(Default value = 0.35)</p>
</div></blockquote>
<p><strong>goto_mu</strong> : float</p>
<blockquote>
<div><p>The mean of the beat errors in the continuously correct
track must be less than this
(Default value = 0.2)</p>
</div></blockquote>
<p><strong>goto_sigma</strong> : float</p>
<blockquote>
<div><p>The std of the beat errors in the continuously correct track must
be less than this
(Default value = 0.2)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>goto_score</strong> : float</p>
<blockquote class="last">
<div><p>Either 1.0 or 0.0 if some specific criteria are met</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">goto_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.p_score">
<code class="descclassname">mir_eval.beat.</code><code class="descname">p_score</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>p_score_threshold=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.p_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Get McKinney&#8217;s P-score.
Based on the autocorrelation of the reference and estimated beats</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>p_score_threshold</strong> : float</p>
<blockquote>
<div><p>Window size will be
<code class="docutils literal"><span class="pre">p_score_threshold*np.median(inter_annotation_intervals)</span></code>,
(Default value = 0.2)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>correlation</strong> : float</p>
<blockquote class="last">
<div><p>McKinney&#8217;s P-score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">p_score</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.continuity">
<code class="descclassname">mir_eval.beat.</code><code class="descname">continuity</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>continuity_phase_threshold=0.175</em>, <em>continuity_period_threshold=0.175</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.continuity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metrics based on how much of the estimated beat sequence is
continually correct.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>continuity_phase_threshold</strong> : float</p>
<blockquote>
<div><p>Allowable ratio of how far is the estimated beat
can be from the reference beat
(Default value = 0.175)</p>
</div></blockquote>
<p><strong>continuity_period_threshold</strong> : float</p>
<blockquote>
<div><p>Allowable distance between the inter-beat-interval
and the inter-annotation-interval
(Default value = 0.175)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>CMLc</strong> : float</p>
<blockquote>
<div><p>Correct metric level, continuous accuracy</p>
</div></blockquote>
<p><strong>CMLt</strong> : float</p>
<blockquote>
<div><p>Correct metric level, total accuracy (continuity not required)</p>
</div></blockquote>
<p><strong>AMLc</strong> : float</p>
<blockquote>
<div><p>Any metric level, continuous accuracy</p>
</div></blockquote>
<p><strong>AMLt</strong> : float</p>
<blockquote class="last">
<div><p>Any metric level, total accuracy (continuity not required)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CMLc</span><span class="p">,</span> <span class="n">CMLt</span><span class="p">,</span> <span class="n">AMLc</span><span class="p">,</span> <span class="n">AMLt</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">continuity</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.information_gain">
<code class="descclassname">mir_eval.beat.</code><code class="descname">information_gain</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>bins=41</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.information_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the information gain - K-L divergence of the beat error histogram
to a uniform histogram</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>query beat times, in seconds</p>
</div></blockquote>
<p><strong>bins</strong> : int</p>
<blockquote>
<div><p>Number of bins in the beat error histogram
(Default value = 41)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>information_gain_score</strong> : float</p>
<blockquote class="last">
<div><p>Entropy of beat error histogram</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">information_gain</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">information_gain</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.evaluate">
<code class="descclassname">mir_eval.beat.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_beats</em>, <em>estimated_beats</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.beat.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference beat times, in seconds</p>
</div></blockquote>
<p><strong>estimated_beats</strong> : np.ndarray</p>
<blockquote>
<div><p>Query beat times, in seconds</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.chord">
<span id="mir-eval-chord"></span><h3><a class="reference internal" href="#module-mir_eval.chord" title="mir_eval.chord"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.chord</span></code></a><a class="headerlink" href="#module-mir_eval.chord" title="Permalink to this headline">¶</a></h3>
<p>Chord estimation algorithms produce a list of intervals and labels which denote
the chord being played over each timespan.  They are evaluated by comparing the
estimated chord labels to some reference, usually using a mapping to a chord
subalphabet (e.g. minor and major chords only, all triads, etc.).  There is no
single &#8216;right&#8217; way to compare two sequences of chord labels.  Embracing this
reality, every conventional comparison rule is provided.  Comparisons are made
over the different components of each chord (e.g. G:maj(6)/5): the root (G),
the root-invariant active semitones as determined by the quality
shorthand (maj) and scale degrees (6), and the bass interval (5).
This submodule provides functions both for comparing a sequences of chord
labels according to some chord subalphabet mapping and for using these
comparisons to score a sequence of estimated chords against a reference.</p>
<div class="section" id="id2">
<h4>Conventions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>A sequence of chord labels is represented as a list of strings, where each
label is the chord name based on the syntax of <a class="footnote-reference" href="#harte2010towards" id="id3">[1]</a>.  Reference
and estimated chord label sequences should be of the same length for comparison
functions.  When converting the chord string into its constituent parts,</p>
<ul class="simple">
<li>Pitch class counting starts at C, e.g. C:0, D:2, E:4, F:5, etc.</li>
<li>Scale degree is represented as a string of the diatonic interval, relative to
the root note, e.g. &#8216;b6&#8217;, &#8216;#5&#8217;, or &#8216;7&#8217;</li>
<li>Bass intervals are represented as strings</li>
<li>Chord bitmaps are positional binary vectors indicating active pitch classes
and may be absolute or relative depending on context in the code.</li>
</ul>
<p>If no chord is present at a given point in time, it should have the label &#8216;N&#8217;,
which is defined in the variable <code class="docutils literal"><span class="pre">mir_eval.chord.NO_CHORD</span></code>.</p>
</div>
<div class="section" id="id4">
<h4>Metrics<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.chord.root" title="mir_eval.chord.root"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.root()</span></code></a>: Only compares the root of the chords.</li>
<li><a class="reference internal" href="#mir_eval.chord.majmin" title="mir_eval.chord.majmin"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.majmin()</span></code></a>: Only compares major, minor, and &#8220;no chord&#8221;
labels.</li>
<li><a class="reference internal" href="#mir_eval.chord.majmin_inv" title="mir_eval.chord.majmin_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.majmin_inv()</span></code></a>: Compares major/minor chords, with
inversions.  The bass note must exist in the triad.</li>
<li><a class="reference internal" href="#mir_eval.chord.mirex" title="mir_eval.chord.mirex"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.mirex()</span></code></a>: A estimated chord is considered correct if it
shares <em>at least</em> three pitch classes in common.</li>
<li><a class="reference internal" href="#mir_eval.chord.thirds" title="mir_eval.chord.thirds"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.thirds()</span></code></a>: Chords are compared at the level of major or
minor thirds (root and third), For example, both (&#8216;A:7&#8217;, &#8216;A:maj&#8217;) and
(&#8216;A:min&#8217;, &#8216;A:dim&#8217;) are equivalent, as the third is major and minor in
quality, respectively.</li>
<li><a class="reference internal" href="#mir_eval.chord.thirds_inv" title="mir_eval.chord.thirds_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.thirds_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.triads" title="mir_eval.chord.triads"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.triads()</span></code></a>: Chords are considered at the level of triads
(major, minor, augmented, diminished, suspended), meaning that, in addition
to the root, the quality is only considered through #5th scale degree (for
augmented chords). For example, (&#8216;A:7&#8217;, &#8216;A:maj&#8217;) are equivalent, while
(&#8216;A:min&#8217;, &#8216;A:dim&#8217;) and (&#8216;A:aug&#8217;, &#8216;A:maj&#8217;) are not.</li>
<li><a class="reference internal" href="#mir_eval.chord.triads_inv" title="mir_eval.chord.triads_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.triads_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.tetrads" title="mir_eval.chord.tetrads"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.tetrads()</span></code></a>: Chords are considered at the level of the
entire quality in closed voicing, i.e. spanning only a single octave;
extended chords (9&#8217;s, 11&#8217;s and 13&#8217;s) are rolled into a single octave with any
upper voices included as extensions. For example, (&#8216;A:7&#8217;, &#8216;A:9&#8217;) are
equivlent but (&#8216;A:7&#8217;, &#8216;A:maj7&#8217;) are not.</li>
<li><a class="reference internal" href="#mir_eval.chord.tetrads_inv" title="mir_eval.chord.tetrads_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.tetrads_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.sevenths" title="mir_eval.chord.sevenths"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.sevenths()</span></code></a>: Compares according to MIREX &#8220;sevenths&#8221;
rules; that is, only major, major seventh, seventh, minor, minor seventh and
no chord labels are compared.</li>
<li><a class="reference internal" href="#mir_eval.chord.sevenths_inv" title="mir_eval.chord.sevenths_inv"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.sevenths_inv()</span></code></a>: Same as above, with inversions (bass
relationships).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">references:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="harte2010towards" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><p class="first last">C. Harte. Towards Automatic Extraction of Harmony
Information from Music Signals. PhD thesis, Queen Mary University of
London, August 2010.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<dl class="exception">
<dt id="mir_eval.chord.InvalidChordException">
<em class="property">exception </em><code class="descclassname">mir_eval.chord.</code><code class="descname">InvalidChordException</code><span class="sig-paren">(</span><em>message=''</em>, <em>chord_label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.InvalidChordException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Exception class for suspect / invalid chord labels</p>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.pitch_class_to_semitone">
<code class="descclassname">mir_eval.chord.</code><code class="descname">pitch_class_to_semitone</code><span class="sig-paren">(</span><em>pitch_class</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.pitch_class_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pitch class to semitone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>pitch_class</strong> : str</p>
<blockquote>
<div><p>Spelling of a given pitch class, e.g. &#8216;C#&#8217;, &#8216;Gbb&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>semitone</strong> : int</p>
<blockquote class="last">
<div><p>Semitone value of the pitch class.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.scale_degree_to_semitone">
<code class="descclassname">mir_eval.chord.</code><code class="descname">scale_degree_to_semitone</code><span class="sig-paren">(</span><em>scale_degree</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.scale_degree_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a scale degree to semitone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scale degree</strong> : str</p>
<blockquote>
<div><p>Spelling of a relative scale degree, e.g. &#8216;b3&#8217;, &#8216;7&#8217;, &#8216;#5&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>semitone</strong> : int</p>
<blockquote class="last">
<div><p>Relative semitone of the scale degree, wrapped to a single octave</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.scale_degree_to_bitmap">
<code class="descclassname">mir_eval.chord.</code><code class="descname">scale_degree_to_bitmap</code><span class="sig-paren">(</span><em>scale_degree</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.scale_degree_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bitmap representation of a scale degree.</p>
<p>Note that values in the bitmap may be negative, indicating that the
semitone is to be removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scale_degree</strong> : str</p>
<blockquote>
<div><p>Spelling of a relative scale degree, e.g. &#8216;b3&#8217;, &#8216;7&#8217;, &#8216;#5&#8217;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, in [-1, 0, 1]</p>
<blockquote class="last">
<div><p>Bitmap representation of this scale degree (12-dim).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.quality_to_bitmap">
<code class="descclassname">mir_eval.chord.</code><code class="descname">quality_to_bitmap</code><span class="sig-paren">(</span><em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.quality_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bitmap for a given quality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quality</strong> : str</p>
<blockquote>
<div><p>Chord quality name.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Bitmap representation of this quality (12-dim).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.reduce_extended_quality">
<code class="descclassname">mir_eval.chord.</code><code class="descname">reduce_extended_quality</code><span class="sig-paren">(</span><em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.reduce_extended_quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Map an extended chord quality to a simpler one, moving upper voices to
a set of scale degree extensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>quality</strong> : str</p>
<blockquote>
<div><p>Extended chord quality to reduce.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>base_quality</strong> : str</p>
<blockquote>
<div><p>New chord quality.</p>
</div></blockquote>
<p><strong>extensions</strong> : set</p>
<blockquote class="last">
<div><p>Scale degrees extensions for the quality.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.validate_chord_label">
<code class="descclassname">mir_eval.chord.</code><code class="descname">validate_chord_label</code><span class="sig-paren">(</span><em>chord_label</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.validate_chord_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for well-formedness of a chord label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord</strong> : str</p>
<blockquote class="last">
<div><p>Chord label to validate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.split">
<code class="descclassname">mir_eval.chord.</code><code class="descname">split</code><span class="sig-paren">(</span><em>chord_label</em>, <em>reduce_extended_chords=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.split" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parse a chord label into its four constituent parts:</dt>
<dd><ul class="first last simple">
<li>root</li>
<li>quality shorthand</li>
<li>scale degrees</li>
<li>bass</li>
</ul>
</dd>
<dt>Note: Chords lacking quality AND interval information are major.</dt>
<dd><ul class="first last simple">
<li>If a quality is specified, it is returned.</li>
<li>If an interval is specified WITHOUT a quality, the quality field is
empty.</li>
</ul>
</dd>
</dl>
<p>Some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>&#39;C&#39; -&gt; [&#39;C&#39;, &#39;maj&#39;, {}, &#39;1&#39;]
&#39;G#:min(*b3,*5)/5&#39; -&gt; [&#39;G#&#39;, &#39;min&#39;, {&#39;*b3&#39;, &#39;*5&#39;}, &#39;5&#39;]
&#39;A:(3)/6&#39; -&gt; [&#39;A&#39;, &#39;&#39;, {&#39;3&#39;}, &#39;6&#39;]
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_label</strong> : str</p>
<blockquote>
<div><p>A chord label.</p>
</div></blockquote>
<p><strong>reduce_extended_chords</strong> : bool</p>
<blockquote>
<div><p>Whether to map the upper voicings of extended chords (9&#8217;s, 11&#8217;s, 13&#8217;s)
to semitone extensions. (Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>chord_parts</strong> : list</p>
<blockquote class="last">
<div><p>Split version of the chord label.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.join">
<code class="descclassname">mir_eval.chord.</code><code class="descname">join</code><span class="sig-paren">(</span><em>chord_root</em>, <em>quality=''</em>, <em>extensions=None</em>, <em>bass=''</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join the parts of a chord into a complete chord label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_root</strong> : str</p>
<blockquote>
<div><p>Root pitch class of the chord, e.g. &#8216;C&#8217;, &#8216;Eb&#8217;</p>
</div></blockquote>
<p><strong>quality</strong> : str</p>
<blockquote>
<div><p>Quality of the chord, e.g. &#8216;maj&#8217;, &#8216;hdim7&#8217;
(Default value = &#8216;&#8217;)</p>
</div></blockquote>
<p><strong>extensions</strong> : list</p>
<blockquote>
<div><p>Any added or absent scaled degrees for this chord, e.g. [&#8216;4&#8217;, &#8216;*3&#8217;]
(Default value = None)</p>
</div></blockquote>
<p><strong>bass</strong> : str</p>
<blockquote>
<div><p>Scale degree of the bass note, e.g. &#8216;5&#8217;.
(Default value = &#8216;&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>chord_label</strong> : str</p>
<blockquote class="last">
<div><p>A complete chord label.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.encode">
<code class="descclassname">mir_eval.chord.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>chord_label</em>, <em>reduce_extended_chords=False</em>, <em>strict_bass_intervals=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a chord label to numerical representations for evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_label</strong> : str</p>
<blockquote>
<div><p>Chord label to encode.</p>
</div></blockquote>
<p><strong>reduce_extended_chords</strong> : bool</p>
<blockquote>
<div><p>Whether to map the upper voicings of extended chords (9&#8217;s, 11&#8217;s, 13&#8217;s)
to semitone extensions.
(Default value = False)</p>
</div></blockquote>
<p><strong>strict_bass_intervals</strong> : bool</p>
<blockquote>
<div><p>Whether to require that the bass scale degree is present in the chord.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>root_number</strong> : int</p>
<blockquote>
<div><p>Absolute semitone of the chord&#8217;s root.</p>
</div></blockquote>
<p><strong>semitone_bitmap</strong> : np.ndarray, dtype=int</p>
<blockquote>
<div><p>12-dim vector of relative semitones in the chord spelling.</p>
</div></blockquote>
<p><strong>bass_number</strong> : int</p>
<blockquote class="last">
<div><p>Relative semitone of the chord&#8217;s bass note, e.g. 0=root, 7=fifth, etc.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.encode_many">
<code class="descclassname">mir_eval.chord.</code><code class="descname">encode_many</code><span class="sig-paren">(</span><em>chord_labels</em>, <em>reduce_extended_chords=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.encode_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a set of chord labels to numerical representations for sane
evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_labels</strong> : list</p>
<blockquote>
<div><p>Set of chord labels to encode.</p>
</div></blockquote>
<p><strong>reduce_extended_chords</strong> : bool</p>
<blockquote>
<div><p>Whether to map the upper voicings of extended chords (9&#8217;s, 11&#8217;s, 13&#8217;s)
to semitone extensions.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>root_number</strong> : np.ndarray, dtype=int</p>
<blockquote>
<div><p>Absolute semitone of the chord&#8217;s root.</p>
</div></blockquote>
<p><strong>interval_bitmap</strong> : np.ndarray, dtype=int</p>
<blockquote>
<div><p>12-dim vector of relative semitones in the given chord quality.</p>
</div></blockquote>
<p><strong>bass_number</strong> : np.ndarray, dtype=int</p>
<blockquote class="last">
<div><p>Relative semitones of the chord&#8217;s bass notes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.rotate_bitmap_to_root">
<code class="descclassname">mir_eval.chord.</code><code class="descname">rotate_bitmap_to_root</code><span class="sig-paren">(</span><em>bitmap</em>, <em>chord_root</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.rotate_bitmap_to_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmap to its asbolute pitch classes.</p>
<p>For clarity, the best explanation is an example. Given &#8216;G:Maj&#8217;, the root
and quality map are as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">root</span><span class="o">=</span><span class="mi">5</span>
<span class="n">quality</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Relative chord shape</span>
</pre></div>
</div>
<p>After rotating to the root, the resulting bitmap becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">abs_quality</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># G, B, and D</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(12,)</p>
<blockquote>
<div><p>Bitmap of active notes, relative to the given root.</p>
</div></blockquote>
<p><strong>chord_root</strong> : int</p>
<blockquote>
<div><p>Absolute pitch class number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(12,)</p>
<blockquote class="last">
<div><p>Absolute bitmap of active pitch classes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.rotate_bitmaps_to_roots">
<code class="descclassname">mir_eval.chord.</code><code class="descname">rotate_bitmaps_to_roots</code><span class="sig-paren">(</span><em>bitmaps</em>, <em>roots</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.rotate_bitmaps_to_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmaps to asbolute pitch classes.</p>
<p>See rotate_bitmap_to_root for more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(N, 12)</p>
<blockquote>
<div><p>Bitmap of active notes, relative to the given root.</p>
</div></blockquote>
<p><strong>root</strong> : np.ndarray, shape=(N,)</p>
<blockquote>
<div><p>Absolute pitch class number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bitmap</strong> : np.ndarray, shape=(N, 12)</p>
<blockquote class="last">
<div><p>Absolute bitmaps of active pitch classes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.validate">
<code class="descclassname">mir_eval.chord.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a comparison function look like
valid chord labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote class="last">
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.weighted_accuracy">
<code class="descclassname">mir_eval.chord.</code><code class="descname">weighted_accuracy</code><span class="sig-paren">(</span><em>comparisons</em>, <em>weights</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.weighted_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted accuracy of a list of chord comparisons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>comparisons</strong> : np.ndarray</p>
<blockquote>
<div><p>List of chord comparison scores, in [0, 1] or -1</p>
</div></blockquote>
<p><strong>weights</strong> : np.ndarray</p>
<blockquote>
<div><p>Weights (not necessarily normalized) for each comparison.
This can be a list of interval durations</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>Weighted accuracy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Here, we&#39;re using the &quot;thirds&quot; function to compare labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but any of the comparison functions would work.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.thirds">
<code class="descclassname">mir_eval.chord.</code><code class="descname">thirds</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.thirds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along root &amp; third relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.thirds_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">thirds_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.thirds_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along root, third, &amp; bass relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.triads">
<code class="descclassname">mir_eval.chord.</code><code class="descname">triads</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.triads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along triad (root &amp; quality to #5) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.triads_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">triads_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.triads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along triad (root, quality to #5, &amp; bass) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.tetrads">
<code class="descclassname">mir_eval.chord.</code><code class="descname">tetrads</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.tetrads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along tetrad (root &amp; full quality) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.tetrads_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">tetrads_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.tetrads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along tetrad (root, full quality, &amp; bass) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.root">
<code class="descclassname">mir_eval.chord.</code><code class="descname">root</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords according to roots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.mirex">
<code class="descclassname">mir_eval.chord.</code><code class="descname">mirex</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.mirex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX rules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">mirex</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.majmin">
<code class="descclassname">mir_eval.chord.</code><code class="descname">majmin</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.majmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules. Chords with qualities outside
Major/minor/no-chord are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.majmin_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">majmin_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.majmin_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules, with inversions. Chords with
qualities outside Major/minor/no-chord are ignored, and the bass note must
exist in the triad (bass in [1, 3, 5]).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.sevenths">
<code class="descclassname">mir_eval.chord.</code><code class="descname">sevenths</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.sevenths" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX &#8216;sevenths&#8217; rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.sevenths_inv">
<code class="descclassname">mir_eval.chord.</code><code class="descname">sevenths_inv</code><span class="sig-paren">(</span><em>reference_labels</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.sevenths_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX &#8216;sevenths&#8217; rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Reference chord labels to score against.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, len=n</p>
<blockquote>
<div><p>Estimated chord labels to score against.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>comparison_scores</strong> : np.ndarray, shape=(n,), dtype=float</p>
<blockquote class="last">
<div><p>Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">ref_intervals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="gp">... </span>    <span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">NO_CHORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge_labeled_intervals</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.evaluate">
<code class="descclassname">mir_eval.chord.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_labels</em>, <em>est_intervals</em>, <em>est_labels</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.chord.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes weighted accuracy for all comparison functions for the given
reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>Reference chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>ref_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.melody">
<span id="mir-eval-melody"></span><h3><a class="reference internal" href="#module-mir_eval.melody" title="mir_eval.melody"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.melody</span></code></a><a class="headerlink" href="#module-mir_eval.melody" title="Permalink to this headline">¶</a></h3>
<p>Melody extraction algorithms aim to produce a sequence of frequency values
corresponding to the pitch of the dominant melody from a musical
recording.  For evaluation, an estimated pitch series is evaluated against a
reference based on whether the voicing (melody present or not) and the pitch
is correct (within some tolerance).</p>
<dl class="docutils">
<dt>For a detailed explanation of the measures please refer to:</dt>
<dd>J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, &#8220;Melody Extraction
from Polyphonic Music Signals: Approaches, Applications and Challenges&#8221;,
IEEE Signal Processing Magazine, 31(2):118-134, Mar. 2014.</dd>
</dl>
<div class="section" id="id5">
<h4>Conventions<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Melody annotations are assumed to be given in the format of a 1d array of
frequency values which are accompanied by a 1d array of times denoting when
each frequency value occurs.  In a reference melody time series, a frequency
value of 0 denotes &#8220;unvoiced&#8221;.  In a estimated melody time series, unvoiced
frames can be indicated either by 0 Hz or by a negative Hz value - negative
values represent the algorithm&#8217;s pitch estimate for frames it has determined as
unvoiced, in case they are in fact voiced.</p>
<p>Metrics are computed using a sequence of reference and estimated pitches in
cents and boolean voicing arrays, both of which are sampled to the same
timebase.  The function <a class="reference internal" href="#mir_eval.melody.to_cent_voicing" title="mir_eval.melody.to_cent_voicing"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.to_cent_voicing()</span></code></a> can be used to
convert a sequence of estimated and reference times and frequency values in Hz
to boolean voicing arrays and frequency arrays in the format required by the
metric functions.  By default, the convention is to resample the estimated
melody time series to the reference melody time series&#8217; timebase.</p>
</div>
<div class="section" id="id6">
<h4>Metrics<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.melody.voicing_measures" title="mir_eval.melody.voicing_measures"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.voicing_measures()</span></code></a>: Voicing measures, including the
recall rate (proportion of frames labeled as melody frames in the reference
that are estimated as melody frames) and the false alarm
rate (proportion of frames labeled as non-melody in the reference that are
mistakenly estimated as melody frames)</li>
<li><a class="reference internal" href="#mir_eval.melody.raw_pitch_accuracy" title="mir_eval.melody.raw_pitch_accuracy"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.raw_pitch_accuracy()</span></code></a>: Raw Pitch Accuracy, which
computes the proportion of melody frames in the reference for which the
frequency is considered correct (i.e. within half a semitone of the reference
frequency)</li>
<li><a class="reference internal" href="#mir_eval.melody.raw_chroma_accuracy" title="mir_eval.melody.raw_chroma_accuracy"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.raw_chroma_accuracy()</span></code></a>: Raw Chroma Accuracy, where the
estimated and reference frequency sequences are mapped onto a single octave
before computing the raw pitch accuracy</li>
<li><a class="reference internal" href="#mir_eval.melody.overall_accuracy" title="mir_eval.melody.overall_accuracy"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.overall_accuracy()</span></code></a>: Overall Accuracy, which computes
the proportion of all frames correctly estimated by the algorithm, including
whether non-melody frames where labeled by the algorithm as non-melody</li>
</ul>
<dl class="function">
<dt id="mir_eval.melody.validate_voicing">
<code class="descclassname">mir_eval.melody.</code><code class="descname">validate_voicing</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>est_voicing</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.validate_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing inputs to a metric are in the correct format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.validate">
<code class="descclassname">mir_eval.melody.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing and frequency arrays are well-formed.  To be used in
conjunction with <a class="reference internal" href="#mir_eval.melody.validate_voicing" title="mir_eval.melody.validate_voicing"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.validate_voicing()</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.hz2cents">
<code class="descclassname">mir_eval.melody.</code><code class="descname">hz2cents</code><span class="sig-paren">(</span><em>freq_hz</em>, <em>base_frequency=10.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.hz2cents" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of frequency values in Hz to cents.
0 values are left in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>freq_hz</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequencies in Hz.</p>
</div></blockquote>
<p><strong>base_frequency</strong> : float</p>
<blockquote>
<div><p>Base frequency for conversion.
(Default value = 10.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cent</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Array of frequencies in cents, relative to base_frequency</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.freq_to_voicing">
<code class="descclassname">mir_eval.melody.</code><code class="descname">freq_to_voicing</code><span class="sig-paren">(</span><em>frequencies</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.freq_to_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from an array of frequency values to frequency array +
voice/unvoiced array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequencies.  A frequency &lt;= 0 indicates &#8220;unvoiced&#8221;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequencies, all &gt;= 0.</p>
</div></blockquote>
<p><strong>voiced</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Boolean array, same length as frequencies,
which indicates voiced or unvoiced</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.constant_hop_timebase">
<code class="descclassname">mir_eval.melody.</code><code class="descname">constant_hop_timebase</code><span class="sig-paren">(</span><em>hop</em>, <em>end_time</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.constant_hop_timebase" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a time series from 0 to <code class="docutils literal"><span class="pre">end_time</span></code> with times spaced <code class="docutils literal"><span class="pre">hop</span></code>
apart</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>hop</strong> : float</p>
<blockquote>
<div><p>Spacing of samples in the time series</p>
</div></blockquote>
<p><strong>end_time</strong> : float</p>
<blockquote>
<div><p>Time series will span <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">end_time]</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Generated timebase</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.resample_melody_series">
<code class="descclassname">mir_eval.melody.</code><code class="descname">resample_melody_series</code><span class="sig-paren">(</span><em>times</em>, <em>frequencies</em>, <em>voicing</em>, <em>times_new</em>, <em>kind='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.resample_melody_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples frequency and voicing time series to a new timescale.  Maintains
any zero (&#8220;unvoiced&#8221;) values in frequencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>Times of each frequency value</p>
</div></blockquote>
<p><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of frequency values, &gt;= 0</p>
</div></blockquote>
<p><strong>voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Boolean array which indicates voiced or unvoiced</p>
</div></blockquote>
<p><strong>times_new</strong> : np.ndarray</p>
<blockquote>
<div><p>Times to resample frequency and voicing sequences to</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>kind parameter to pass to scipy.interpolate.interp1d.
(Default value = &#8216;linear&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>frequencies_resampled</strong> : np.ndarray</p>
<blockquote>
<div><p>Frequency array resampled to new timebase</p>
</div></blockquote>
<p><strong>voicing_resampled</strong> : np.ndarray, dtype=bool</p>
<blockquote class="last">
<div><p>Boolean voicing array resampled to new timebase</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.to_cent_voicing">
<code class="descclassname">mir_eval.melody.</code><code class="descname">to_cent_voicing</code><span class="sig-paren">(</span><em>ref_time</em>, <em>ref_freq</em>, <em>est_time</em>, <em>est_freq</em>, <em>base_frequency=10.0</em>, <em>hop=None</em>, <em>kind='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.to_cent_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts reference and estimated time/frequency (Hz) annotations to sampled
frequency (cent)/voicing arrays.</p>
<p>A zero frequency indicates &#8220;unvoiced&#8221;.</p>
<p>A negative frequency indicates &#8220;Predicted as unvoiced, but if it&#8217;s voiced,
this is the frequency estimate&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each reference frequency value</p>
</div></blockquote>
<p><strong>ref_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of reference frequency values</p>
</div></blockquote>
<p><strong>est_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each estimated frequency value</p>
</div></blockquote>
<p><strong>est_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of estimated frequency values</p>
</div></blockquote>
<p><strong>base_frequency</strong> : float</p>
<blockquote>
<div><p>Base frequency in Hz for conversion to cents
(Default value = 10.)</p>
</div></blockquote>
<p><strong>hop</strong> : float</p>
<blockquote>
<div><p>Hop size, in seconds, to resample,
default None which means use ref_time</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>kind parameter to pass to scipy.interpolate.interp1d.
(Default value = &#8216;linear&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray, dtype=bool</p>
<blockquote>
<div><p>Resampled reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Resampled reference frequency (cent) array</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray, dtype=bool</p>
<blockquote>
<div><p>Resampled estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Resampled estimated frequency (cent) array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.voicing_measures">
<code class="descclassname">mir_eval.melody.</code><code class="descname">voicing_measures</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>est_voicing</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.voicing_measures" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the voicing recall and false alarm rates given two voicing
indicator sequences, one as reference (truth) and the other as the estimate
(prediction).  The sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vx_recall</strong> : float</p>
<blockquote>
<div><p>Voicing recall rate, the fraction of voiced frames in ref
indicated as voiced in est</p>
</div></blockquote>
<p><strong>vx_false_alarm</strong> : float</p>
<blockquote class="last">
<div><p>Voicing false alarm rate, the fraction of unvoiced frames in ref
indicated as voiced in est</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span><span class="p">,</span> <span class="n">false_alarm</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">voicing_measures</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span>
<span class="gp">... </span>                                                       <span class="n">est_v</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.raw_pitch_accuracy">
<code class="descclassname">mir_eval.melody.</code><code class="descname">raw_pitch_accuracy</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.raw_pitch_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw pitch accuracy given two pitch (frequency) sequences in
cents and matching voicing indicator sequences. The first pitch and voicing
arrays are treated as the reference (truth), and the second two as the
estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
<p><strong>cent_tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum absolute deviation for a cent value to be considerd correct
(Default value = 50)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw_pitch</strong> : float</p>
<blockquote class="last">
<div><p>Raw pitch accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values
(within cent_tolerance cents).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_pitch</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_pitch_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                               <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.raw_chroma_accuracy">
<code class="descclassname">mir_eval.melody.</code><code class="descname">raw_chroma_accuracy</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.raw_chroma_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw chroma accuracy given two pitch (frequency) sequences
in cents and matching voicing indicator sequences. The first pitch and
voicing arrays are treated as the reference (truth), and the second two as
the estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
<p><strong>cent_tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum absolute deviation for a cent value to be considered correct
(Default value = 50)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw_chroma</strong> : float</p>
<blockquote class="last">
<div><p>Raw chroma accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values (within
cent_tolerance cents), ignoring octave errors</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[2]</a></td><td>J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, &#8220;Melody
Extraction from Polyphonic Music Signals: Approaches, Applications
and Challenges&#8221;, IEEE Signal Processing Magazine, 31(2):118-134,
Mar. 2014.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. &#8220;Melody transcription from music audio:
Approaches and evaluation&#8221;, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_chroma_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.overall_accuracy">
<code class="descclassname">mir_eval.melody.</code><code class="descname">overall_accuracy</code><span class="sig-paren">(</span><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.overall_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the overall accuracy given two pitch (frequency) sequences in cents
and matching voicing indicator sequences. The first pitch and voicing
arrays are treated as the reference (truth), and the second two as the
estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference boolean voicing array</p>
</div></blockquote>
<p><strong>ref_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Reference pitch sequence in cents</p>
</div></blockquote>
<p><strong>est_voicing</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimated boolean voicing array</p>
</div></blockquote>
<p><strong>est_cent</strong> : np.ndarray</p>
<blockquote>
<div><p>Estimate pitch sequence in cents</p>
</div></blockquote>
<p><strong>cent_tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum absolute deviation for a cent value to be considered correct
(Default value = 50)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>overall_accuracy</strong> : float</p>
<blockquote class="last">
<div><p>Overall accuracy, the total fraction of correctly estimates frames,
where provides a correct frequency values (within cent_tolerance
cents).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">to_cent_voicing</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_time</span><span class="p">,</span>
<span class="gp">... </span>                                                 <span class="n">est_freq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">overall_accuracy</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">overall_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="gp">... </span>                                                    <span class="n">est_v</span><span class="p">,</span> <span class="n">est_c</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.evaluate">
<code class="descclassname">mir_eval.melody.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_time</em>, <em>ref_freq</em>, <em>est_time</em>, <em>est_freq</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.melody.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate two melody (predominant f0) transcriptions, where the first is
treated as the reference (ground truth) and the second as the estimate to
be evaluated (prediction).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each reference frequency value</p>
</div></blockquote>
<p><strong>ref_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of reference frequency values</p>
</div></blockquote>
<p><strong>est_time</strong> : np.ndarray</p>
<blockquote>
<div><p>Time of each estimated frequency value</p>
</div></blockquote>
<p><strong>est_freq</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of estimated frequency values</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s1">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.onset">
<span id="mir-eval-onset"></span><h3><a class="reference internal" href="#module-mir_eval.onset" title="mir_eval.onset"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.onset</span></code></a><a class="headerlink" href="#module-mir_eval.onset" title="Permalink to this headline">¶</a></h3>
<p>The goal of an onset detection algorithm is to automatically determine when
notes are played in a piece of music.  The primary method used to evaluate
onset detectors is to first determine which estimated onsets are &#8220;correct&#8221;,
where correctness is defined as being within a small window of a reference
onset.</p>
<p>Based in part on this script:</p>
<blockquote>
<div><a class="reference external" href="https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py">https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py</a></div></blockquote>
<div class="section" id="id9">
<h4>Conventions<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>Onsets should be provided in the form of a 1-dimensional array of onset
times in seconds in increasing order.</p>
</div>
<div class="section" id="id10">
<h4>Metrics<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.onset.f_measure" title="mir_eval.onset.f_measure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.onset.f_measure()</span></code></a>: Precision, Recall, and F-measure scores
based on the number of esimated onsets which are sufficiently close to
reference onsets.</li>
</ul>
<dl class="function">
<dt id="mir_eval.onset.validate">
<code class="descclassname">mir_eval.onset.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_onsets</em>, <em>estimated_onsets</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid onset time
arrays, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>reference onset locations, in seconds</p>
</div></blockquote>
<p><strong>estimated_onsets</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>estimated onset locations, in seconds</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.onset.f_measure">
<code class="descclassname">mir_eval.onset.</code><code class="descname">f_measure</code><span class="sig-paren">(</span><em>reference_onsets</em>, <em>estimated_onsets</em>, <em>window=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted onsets.
&#8220;Corectness&#8221; is determined over a small window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>reference onset locations, in seconds</p>
</div></blockquote>
<p><strong>estimated_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>estimated onset locations, in seconds</p>
</div></blockquote>
<p><strong>window</strong> : float</p>
<blockquote>
<div><p>Window size, in seconds
(Default value = .05)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>2*precision*recall/(precision + recall)</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>(# true positives)/(# true positives + # false positives)</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>(# true positives)/(# true positives + # false negatives)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">estimated_onsets</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.onset.evaluate">
<code class="descclassname">mir_eval.onset.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_onsets</em>, <em>estimated_onsets</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.onset.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>reference onset locations, in seconds</p>
</div></blockquote>
<p><strong>estimated_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>estimated onset locations, in seconds</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="gp">... </span>                                 <span class="n">estimated_onsets</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.pattern">
<span id="mir-eval-pattern"></span><h3><a class="reference internal" href="#module-mir_eval.pattern" title="mir_eval.pattern"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.pattern</span></code></a><a class="headerlink" href="#module-mir_eval.pattern" title="Permalink to this headline">¶</a></h3>
<p>Pattern discovery involves the identification of musical patterns (i.e. short
fragments or melodic ideas that repeat at least twice) both from audio and
symbolic representations.  The metrics used to evaluate pattern discovery
systems attempt to quantify the ability of the algorithm to not only determine
the present patterns in a piece, but also to find all of their occurrences.</p>
<dl class="docutils">
<dt>Based on the methods described here:</dt>
<dd>T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</dd>
</dl>
<div class="section" id="id11">
<h4>Conventions<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>The input format can be automatically generated by calling
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a>.  This format is a list of a list of
tuples.  The first list collections patterns, each of which is a list of
occurences, and each occurrence is a list of MIDI onset tuples of
<code class="docutils literal"><span class="pre">(onset_time,</span> <span class="pre">mid_note)</span></code></p>
<p>A pattern is a list of occurrences. The first occurrence must be the prototype
of that pattern (i.e. the most representative of all the occurrences).  An
occurrence is a list of tuples containing the onset time and the midi note
number.</p>
</div>
<div class="section" id="id12">
<h4>Metrics<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.pattern.standard_FPR" title="mir_eval.pattern.standard_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.standard_FPR()</span></code></a>: Strict metric in order to find the
possibly transposed patterns of exact length. This is the only metric that
considers transposed patterns.</li>
<li><a class="reference internal" href="#mir_eval.pattern.establishment_FPR" title="mir_eval.pattern.establishment_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.establishment_FPR()</span></code></a>: Evaluates the amount of patterns
that were successfully identified by the estimated results, no matter how
many occurrences they found.  In other words, this metric captures how the
algorithm successfully <em>established</em> that a pattern repeated at least twice,
and this pattern is also found in the reference annotation.</li>
<li><a class="reference internal" href="#mir_eval.pattern.occurrence_FPR" title="mir_eval.pattern.occurrence_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.occurrence_FPR()</span></code></a>: Evaluation of how well an estimation
can effectively identify all the occurrences of the found patterns,
independently of how many patterns have been discovered. This metric has a
threshold parameter that indicates how similar two occurrences must be in
order to be considered equal.  In MIREX, this evaluation is run twice, with
thresholds .75 and .5.</li>
<li><a class="reference internal" href="#mir_eval.pattern.three_layer_FPR" title="mir_eval.pattern.three_layer_FPR"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.three_layer_FPR()</span></code></a>: Aims to evaluate the general
similarity between the reference and the estimations, combining both the
establishment of patterns and the retrieval of its occurrences in a single F1
score.</li>
<li><a class="reference internal" href="#mir_eval.pattern.first_n_three_layer_P" title="mir_eval.pattern.first_n_three_layer_P"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.first_n_three_layer_P()</span></code></a>: Computes the three-layer
precision for the first N patterns only in order to measure the ability of
the algorithm to sort the identified patterns based on their relevance.</li>
<li><a class="reference internal" href="#mir_eval.pattern.first_n_target_proportion_R" title="mir_eval.pattern.first_n_target_proportion_R"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.first_n_target_proportion_R()</span></code></a>: Computes the target
proportion recall for the first N patterns only in order to measure the
ability of the algorithm to sort the identified patterns based on their
relevance.</li>
</ul>
<dl class="function">
<dt id="mir_eval.pattern.validate">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid pattern
lists, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote class="last">
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.standard_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">standard_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>tol=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.standard_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard F1 Score, Precision and Recall.</p>
<p>This metric checks if the prototype patterns of the reference match
possible translated patterns in the prototype patterns of the estimations.
Since the sizes of these prototypes must be equal, this metric is quite
restictive and it tends to be 0 in most of 2013 MIREX results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance level when comparing reference against estimation.
Default parameter is the one found in the original matlab code by
Tom Collins used for MIREX 2013.
(Default value = 1e-5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The standard F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The standard Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The standard Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">standard_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.establishment_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">establishment_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>similarity_metric='cardinality_score'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.establishment_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>similarity_metric</strong> : str</p>
<blockquote>
<div><p>A string representing the metric to be used when computing the
similarity matrix. Accepted values:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;cardinality_score&#8221;: Count of the intersection
between occurrences.</li>
</ul>
</div></blockquote>
<p>(Default value = &#8220;cardinality_score&#8221;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The establishment F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The establishment Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The establishment Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">establishment_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.occurrence_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">occurrence_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>thres=0.75</em>, <em>similarity_metric='cardinality_score'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.occurrence_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>thres</strong> : float</p>
<blockquote>
<div><p>How similar two occcurrences must be in order to be considered
equal
(Default value = .75)</p>
</div></blockquote>
<p><strong>similarity_metric</strong> : str</p>
<blockquote>
<div><p>A string representing the metric to be used
when computing the similarity matrix. Accepted values:</p>
<blockquote>
<div><ul class="simple">
<li>&#8220;cardinality_score&#8221;: Count of the intersection
between occurrences.</li>
</ul>
</div></blockquote>
<p>(Default value = &#8220;cardinality_score&#8221;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The establishment F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The establishment Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The establishment Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">occurrence_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.three_layer_FPR">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">three_layer_FPR</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.three_layer_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Three Layer F1 Score, Precision and Recall. As described by Meridith.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote>
<div><p>The three-layer F1 Score</p>
</div></blockquote>
<p><strong>precision</strong> : float</p>
<blockquote>
<div><p>The three-layer Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The three-layer Recall</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">three_layer_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.first_n_three_layer_P">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">first_n_three_layer_P</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.first_n_three_layer_P" title="Permalink to this definition">¶</a></dt>
<dd><p>First n three-layer precision.</p>
<p>This metric is basically the same as the three-layer FPR but it is only
applied to the first n estimated patterns, and it only returns the
precision. In MIREX and typically, n = 5.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Number of patterns to consider from the estimated results, in
the order they appear in the matrix
(Default value = 5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote class="last">
<div><p>The first n three-layer Precision</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_three_layer_P</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_patterns</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.first_n_target_proportion_R">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">first_n_target_proportion_R</code><span class="sig-paren">(</span><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.first_n_target_proportion_R" title="Permalink to this definition">¶</a></dt>
<dd><p>First n target proportion establishment recall metric.</p>
<p>This metric is similar is similar to the establishment FPR score, but it
only takes into account the first n estimated patterns and it only
outputs the Recall value of it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>estimated_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Number of patterns to consider from the estimated results, in
the order they appear in the matrix.
(Default value = 5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>recall</strong> : float</p>
<blockquote class="last">
<div><p>The first n target proportion Recall.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_target_proportion_R</span><span class="p">(</span>
<span class="gp">... </span>                                <span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.evaluate">
<code class="descclassname">mir_eval.pattern.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_patterns</em>, <em>est_patterns</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.pattern.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data and perform the evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_patterns</strong> : list</p>
<blockquote>
<div><p>The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></code></a></p>
</div></blockquote>
<p><strong>est_patterns</strong> : list</p>
<blockquote>
<div><p>The estimated patterns in the same format</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s2">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.segment">
<span id="mir-eval-segment"></span><h3><a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.segment</span></code></a><a class="headerlink" href="#module-mir_eval.segment" title="Permalink to this headline">¶</a></h3>
<p>Evaluation criteria for structural segmentation fall into two categories:
boundary annotation and structural annotation.  Boundary annotation is the task
of predicting the times at which structural changes occur, such as when a verse
transitions to a refrain.  Metrics for boundary annotation compare estimated
segment boundaries to reference boundaries.  Structural annotation is the task
of assigning labels to detected segments.  The estimated labels may be
arbitrary strings - such as A, B, C, - and they need not describe functional
concepts.  Metrics for structural annotation are similar to those used for
clustering data.</p>
<div class="section" id="id13">
<h4>Conventions<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>Both boundary and structural annotation metrics require two dimensional arrays
with two columns, one for boundary start times and one for boundary end times.
Structural annotation further require lists of reference and estimated segment
labels which must have a length which is equal to the number of rows in the
corresponding list of boundary edges.  In both tasks, we assume that
annotations express a partitioning of the track into intervals.  The function
<a class="reference internal" href="#mir_eval.util.adjust_intervals" title="mir_eval.util.adjust_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.util.adjust_intervals()</span></code></a> can be used to pad or crop the segment
boundaries to span the duration of the entire track.</p>
</div>
<div class="section" id="id14">
<h4>Metrics<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.segment.detection" title="mir_eval.segment.detection"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.detection()</span></code></a>: An estimated boundary is considered
correct if it falls within a window around a reference boundary</li>
<li><a class="reference internal" href="#mir_eval.segment.deviation" title="mir_eval.segment.deviation"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.deviation()</span></code></a>: Computes the median absolute time
difference from a reference boundary to its nearest estimated boundary, and
vice versa</li>
<li><a class="reference internal" href="#mir_eval.segment.pairwise" title="mir_eval.segment.pairwise"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.pairwise()</span></code></a>: For classifying pairs of sampled time
instants as belonging to the same structural component</li>
<li><a class="reference internal" href="#mir_eval.segment.rand_index" title="mir_eval.segment.rand_index"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.rand_index()</span></code></a>: Clusters reference and estimated
annotations and compares them by the Rand Index</li>
<li><a class="reference internal" href="#mir_eval.segment.ari" title="mir_eval.segment.ari"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.ari()</span></code></a>: Computes the Rand index, adjusted for chance</li>
<li><a class="reference internal" href="#mir_eval.segment.nce" title="mir_eval.segment.nce"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.nce()</span></code></a>: Interprets sampled reference and estimated
labels as samples of random variables <img class="math" src="_images/math/5e1717f31016291ad604e19f74952cdb330eb10c.png" alt="Y_R, Y_E"/> from which the
conditional entropy of <img class="math" src="_images/math/f7eb8a6744a4e99e694ee0f8739d52ab8a2dd785.png" alt="Y_R"/> given <img class="math" src="_images/math/b5b83fea61694a61a2537f88e3c7a8c10b463191.png" alt="Y_E"/> (Under-Segmentation) and
<img class="math" src="_images/math/b5b83fea61694a61a2537f88e3c7a8c10b463191.png" alt="Y_E"/> given <img class="math" src="_images/math/f7eb8a6744a4e99e694ee0f8739d52ab8a2dd785.png" alt="Y_R"/> (Over-Segmentation) are estimated</li>
<li><a class="reference internal" href="#mir_eval.segment.mutual_information" title="mir_eval.segment.mutual_information"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.mutual_information()</span></code></a>: Computes the standard,
normalized, and adjusted mutual information of sampled reference and
estimated segments</li>
</ul>
<dl class="function">
<dt id="mir_eval.segment.validate_boundary">
<code class="descclassname">mir_eval.segment.</code><code class="descname">validate_boundary</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>trim</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.validate_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a segment boundary estimation
metric (i.e. one that only takes in segment intervals) look like valid
segment times, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>trim</strong> : bool</p>
<blockquote class="last">
<div><p>will the start and end events be trimmed?</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.validate_structure">
<code class="descclassname">mir_eval.segment.</code><code class="descname">validate_structure</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.validate_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a structure estimation metric (i.e.
one that takes in both segment boundaries and their labels) look like valid
segment times and labels, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote class="last">
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.detection">
<code class="descclassname">mir_eval.segment.</code><code class="descname">detection</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>window=0.5</em>, <em>beta=1.0</em>, <em>trim=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boundary detection hit-rate.</p>
<p>A hit is counted whenever an reference boundary is within <code class="docutils literal"><span class="pre">window</span></code> of a
estimated boundary.  Note that each boundary is matched at most once: this
is achieved by computing the size of a maximal matching between reference
and estimated boundary points, subject to the window constraint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>window</strong> : float &gt; 0</p>
<blockquote>
<div><p>size of the window of &#8216;correctness&#8217; around ground-truth beats
(in seconds)
(Default value = 0.5)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>weighting constant for F-measure.
(Default value = 1.0)</p>
</div></blockquote>
<p><strong>trim</strong> : boolean</p>
<blockquote>
<div><p>if <code class="docutils literal"><span class="pre">True</span></code>, the first and last boundary times are ignored.
Typically, these denote start (0) and end-markers.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>precision of estimated predictions</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>recall of reference reference boundaries</p>
</div></blockquote>
<p><strong>f_measure</strong> : float</p>
<blockquote class="last">
<div><p>F-measure (weighted harmonic mean of <code class="docutils literal"><span class="pre">precision</span></code> and <code class="docutils literal"><span class="pre">recall</span></code>)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With 0.5s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P05</span><span class="p">,</span> <span class="n">R05</span><span class="p">,</span> <span class="n">F05</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># With 3s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P3</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">F3</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">window</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Ignoring hits for the beginning and end of track</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">window</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">trim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.deviation">
<code class="descclassname">mir_eval.segment.</code><code class="descname">deviation</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>trim=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.deviation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median deviations between reference
and estimated boundary times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>trim</strong> : boolean</p>
<blockquote>
<div><p>if <code class="docutils literal"><span class="pre">True</span></code>, the first and last intervals are ignored.
Typically, these denote start (0.0) and end-of-track markers.
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>reference_to_estimated</strong> : float</p>
<blockquote>
<div><p>median time from each reference boundary to the
closest estimated boundary</p>
</div></blockquote>
<p><strong>estimated_to_reference</strong> : float</p>
<blockquote class="last">
<div><p>median time from each estimated boundary to the
closest reference boundary</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_to_e</span><span class="p">,</span> <span class="n">e_to_r</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">deviation</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                             <span class="n">est_intervals</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.pairwise">
<code class="descclassname">mir_eval.segment.</code><code class="descname">pairwise</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation evaluation by pair-wise agreement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta value for F-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float &gt; 0</p>
<blockquote>
<div><p>Precision of detecting whether frames belong in the same cluster</p>
</div></blockquote>
<p><strong>recall</strong> : float &gt; 0</p>
<blockquote>
<div><p>Recall of detecting whether frames belong in the same cluster</p>
</div></blockquote>
<p><strong>f</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>F-measure of detecting whether frames belong in the same cluster</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                   <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.rand_index">
<code class="descclassname">mir_eval.segment.</code><code class="descname">rand_index</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.rand_index" title="Permalink to this definition">¶</a></dt>
<dd><p>(Non-adjusted) Rand index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta value for F-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rand_index</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>Rand index</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rand_index</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">rand_index</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                           <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.ari">
<code class="descclassname">mir_eval.segment.</code><code class="descname">ari</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.ari" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusted Rand Index (ARI) for frame clustering segmentation evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ari_score</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>Adjusted Rand index between segmentations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ari_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">ari</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.mutual_information">
<code class="descclassname">mir_eval.segment.</code><code class="descname">mutual_information</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.mutual_information" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: mutual information metrics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>MI</strong> : float &gt; 0</p>
<blockquote>
<div><p>Mutual information between segmentations</p>
</div></blockquote>
<p><strong>AMI</strong> : float</p>
<blockquote>
<div><p>Adjusted mutual information between segmentations.</p>
</div></blockquote>
<p><strong>NMI</strong> : float &gt; 0</p>
<blockquote class="last">
<div><p>Normalize mutual information between segmentations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mi</span><span class="p">,</span> <span class="n">ami</span><span class="p">,</span> <span class="n">nmi</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                                     <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.nce">
<code class="descclassname">mir_eval.segment.</code><code class="descname">nce</code><span class="sig-paren">(</span><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.nce" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: normalized conditional entropy</p>
<p>Computes cross-entropy of cluster assignment, normalized by the
max-entropy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>reference_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>estimated_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames for clustering
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta for F-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">S_over</p>
<blockquote>
<div><p>Over-clustering score:
<code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">log(|y_est|)</span></code>
If <cite>|y_est|==1</cite>, then <cite>S_over</cite> will be 0.</p>
</div></blockquote>
<p>S_under</p>
<blockquote>
<div><p>Under-clustering score:
<code class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">log(|y_ref|)</span></code>
If <cite>|y_ref|==1</cite>, then <cite>S_under</cite> will be 0.</p>
</div></blockquote>
<p>S_F</p>
<blockquote class="last">
<div><p>F-measure for (S_over, S_under)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">,</span> <span class="n">t_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_max</span><span class="o">=</span><span class="n">ref_intervals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_over</span><span class="p">,</span> <span class="n">S_under</span><span class="p">,</span> <span class="n">S_F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">nce</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.evaluate">
<code class="descclassname">mir_eval.segment.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_labels</em>, <em>est_intervals</em>, <em>est_labels</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.segment.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>ref_labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m, 2)</p>
<blockquote>
<div><p>estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>est_labels</strong> : list, shape=(m,)</p>
<blockquote>
<div><p>estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">ref_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">est_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s1">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.hierarchy">
<span id="mir-eval-hierarchy"></span><h3><a class="reference internal" href="#module-mir_eval.hierarchy" title="mir_eval.hierarchy"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.hierarchy</span></code></a><a class="headerlink" href="#module-mir_eval.hierarchy" title="Permalink to this headline">¶</a></h3>
<p>Evaluation criteria for hierarchical structure analysis.</p>
<p>Hierarchical structure analysis seeks to annotate a track with a nested
decomposition of the temporal elements of the piece, effectively providing
a kind of &#8220;parse tree&#8221; of the composition.  Unlike the flat segmentation
metrics defined in <a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.segment</span></code></a>, which can only encode one level of
analysis, hierarchical annotations expose the relationships between short
segments and the larger compositional elements to which they belong.</p>
<p>Currently, there exist no metrics for evaluating hierarchical segment
labeling.  All evaluations are therefore based on boundaries between
segments (and relationships between segments across levels), and not the
labels applied to segments.</p>
<div class="section" id="id15">
<h4>Conventions<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>Annotations are assumed to take the form of an ordered list of segmentations.
As in the <a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.segment</span></code></a> metrics, each segmentation itself consists of
an n-by-2 array of interval times, so that the <code class="docutils literal"><span class="pre">i</span></code> th segment spans time
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
<p>Hierarchical annotations are ordered by increasing specificity, so that the
first segmentation should contain the fewest segments, and the last
segmentation contains the most.</p>
</div>
<div class="section" id="id16">
<h4>Metrics<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.hierarchy.tmeasure" title="mir_eval.hierarchy.tmeasure"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.hierarchy.tmeasure()</span></code></a>: Precision, recall, and F-measure of
triplet-based frame accuracy.</li>
</ul>
</div>
<div class="section" id="references">
<h4>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><table class="docutils footnote" frame="void" id="mcfee2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Brian McFee, Oriol Nieto, and Juan P. Bello.
&#8220;Hierarchical evaluation of segment boundary detection&#8221;,
International Society for Music Information Retrieval (ISMIR) conference,
2015.</td></tr>
</tbody>
</table>
</div></blockquote>
<dl class="function">
<dt id="mir_eval.hierarchy.validate_hier_intervals">
<code class="descclassname">mir_eval.hierarchy.</code><code class="descname">validate_hier_intervals</code><span class="sig-paren">(</span><em>intervals_hier</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.validate_hier_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate a hierarchical segment annotation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals_hier</strong> : ordered list of segmentations</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If any segmentation does not span the full duration of the top-level
segmentation.</p>
<p>If any segmentation does not start at 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.hierarchy.tmeasure">
<code class="descclassname">mir_eval.hierarchy.</code><code class="descname">tmeasure</code><span class="sig-paren">(</span><em>reference_intervals_hier</em>, <em>estimated_intervals_hier</em>, <em>transitive=False</em>, <em>window=15.0</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.tmeasure" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the tree measures for hierarchical segment annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_intervals_hier</strong> : list of ndarray</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">reference_intervals_hier[i]</span></code> contains the segment intervals
(in seconds) for the <code class="docutils literal"><span class="pre">i</span></code> th layer of the annotations.  Layers are
ordered from top to bottom, so that the last list of intervals should
be the most specific.</p>
</div></blockquote>
<p><strong>estimated_intervals_hier</strong> : list of ndarray</p>
<blockquote>
<div><p>Like <code class="docutils literal"><span class="pre">reference_intervals_hier</span></code> but for the estimated annotation</p>
</div></blockquote>
<p><strong>transitive</strong> : bool</p>
<blockquote>
<div><p>whether to compute the t-measures using transitivity or not.</p>
</div></blockquote>
<p><strong>window</strong> : float &gt; 0</p>
<blockquote>
<div><p>size of the window (in seconds).  For each query frame q,
result frames are only counted within q +- window.</p>
</div></blockquote>
<p><strong>frame_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>length (in seconds) of frames.  The frame size cannot be longer than
the window.</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>beta parameter for the F-measure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>t_precision</strong> : number [0, 1]</p>
<blockquote>
<div><p>T-measure Precision</p>
</div></blockquote>
<p><strong>t_recall</strong> : number [0, 1]</p>
<blockquote>
<div><p>T-measure Recall</p>
</div></blockquote>
<p><strong>t_measure</strong> : number [0, 1]</p>
<blockquote>
<div><p>F-beta measure for <code class="docutils literal"><span class="pre">(t_precision,</span> <span class="pre">t_recall)</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If either of the input hierarchies are inconsistent</p>
<p>If the input hierarchies have different time durations</p>
<p>If <code class="docutils literal"><span class="pre">frame_size</span> <span class="pre">&gt;</span> <span class="pre">window</span></code> or <code class="docutils literal"><span class="pre">frame_size</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.hierarchy.evaluate">
<code class="descclassname">mir_eval.hierarchy.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals_hier</em>, <em>ref_labels_hier</em>, <em>est_intervals_hier</em>, <em>est_labels_hier</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.hierarchy.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all hierarchical structure metrics for the given reference and
estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals_hier</strong> : list of list-like</p>
<p><strong>ref_labels_hier</strong> : list of str</p>
<p><strong>est_intervals_hier</strong> : list of list-like</p>
<p><strong>est_labels_hier</strong> : list of str</p>
<blockquote>
<div><p>Hierarchical annotations are encoded as an ordered list
of segmentations.  Each segmentation itself is a list (or list-like)
of intervals (*_intervals_hier) and a list of lists of labels
(*_labels_hier).</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>additional keyword arguments to the evaluation metrics.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> :  OrderedDict</p>
<blockquote>
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
<p>T-measures are computed in both the &#8220;full&#8221; (<code class="docutils literal"><span class="pre">transitive=True</span></code>) and
&#8220;reduced&#8221; (<code class="docutils literal"><span class="pre">transitive=False</span></code>) modes.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>Thrown when the provided annotations are not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>A toy example with two two-layer annotations</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_i</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_i</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">],</span> <span class="p">[</span><span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_l</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_l</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_i</span><span class="p">,</span> <span class="n">ref_l</span><span class="p">,</span> <span class="n">est_i</span><span class="p">,</span> <span class="n">est_l</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="go">{&#39;T-Measure full&#39;: 0.94822745804853459,</span>
<span class="go"> &#39;T-Measure reduced&#39;: 0.8732458222764804,</span>
<span class="go"> &#39;T-Precision full&#39;: 0.96569179094693058,</span>
<span class="go"> &#39;T-Precision reduced&#39;: 0.89939075137018787,</span>
<span class="go"> &#39;T-Recall full&#39;: 0.93138358189386117,</span>
<span class="go"> &#39;T-Recall reduced&#39;: 0.84857799953694923}</span>
</pre></div>
</div>
<p>A more realistic example, using SALAMI pre-parsed annotations</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">load_salami</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;load SALAMI event format as labeled intervals&quot;</span>
<span class="gp">... </span>    <span class="n">events</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_events</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">intervals</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">boundaries_to_intervals</span><span class="p">(</span><span class="n">events</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">labels</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data/10/parsed/textfile1_uppercase.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;data/10/parsed/textfile1_lowercase.txt&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;data/10/parsed/textfile2_uppercase.txt&#39;</span><span class="p">,</span>
<span class="gp">... </span>             <span class="s1">&#39;data/10/parsed/textfile2_lowercase.txt&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref</span> <span class="o">=</span> <span class="p">[</span><span class="n">load_salami</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">ref_files</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_int</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ref_lab</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">ref</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="p">[</span><span class="n">load_salami</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">est_files</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_int</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">est</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_lab</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">est</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_int</span><span class="p">,</span> <span class="n">ref_lab</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">est_hier</span><span class="p">,</span> <span class="n">est_lab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
<span class="go">{&#39;T-Measure full&#39;: 0.66029225561405358,</span>
<span class="go"> &#39;T-Measure reduced&#39;: 0.62001868041578034,</span>
<span class="go"> &#39;T-Precision full&#39;: 0.66844764668949885,</span>
<span class="go"> &#39;T-Precision reduced&#39;: 0.63252297209957919,</span>
<span class="go"> &#39;T-Recall full&#39;: 0.6523334654992341,</span>
<span class="go"> &#39;T-Recall reduced&#39;: 0.60799919710921635}</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.separation">
<span id="mir-eval-separation"></span><h3><a class="reference internal" href="#module-mir_eval.separation" title="mir_eval.separation"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.separation</span></code></a><a class="headerlink" href="#module-mir_eval.separation" title="Permalink to this headline">¶</a></h3>
<p>Source separation algorithms attempt to extract recordings of individual
sources from a recording of a mixture of sources.  Evaluation methods for
source separation compare the extracted sources from reference sources and
attempt to measure the perceptual quality of the separation.</p>
<dl class="docutils">
<dt>Currently, only bss_eval is implemented, as described in:</dt>
<dd>Emmanuel Vincent, Rémi Gribonval, and Cédric Févotte, &#8220;Performance
measurement in blind audio source separation,&#8221; IEEE Trans. on Audio,
Speech and Language Processing, 14(4):1462-1469, 2006.</dd>
<dt>See also the bss_eval MATLAB toolbox:</dt>
<dd><a class="reference external" href="http://bass-db.gforge.inria.fr/bss_eval/">http://bass-db.gforge.inria.fr/bss_eval/</a></dd>
</dl>
<div class="section" id="id17">
<h4>Conventions<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>An audio signal is expected to be in the format of a 1-dimensional array where
the entries are the samples of the audio signal.  When providing a group of
estimated or reference sources, they should be provided in a 2-dimensional
array, where the first dimension corresponds to the source number and the
second corresponds to the samples.</p>
</div>
<div class="section" id="id18">
<h4>Metrics<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources()</span></code></a>: Computes the bss_eval metrics,
which optimally match the estimated sources to the reference sources and
measure the distortion and artifacts present in the estimated sources as well
as the interference between them.</li>
</ul>
<dl class="function">
<dt id="mir_eval.separation.validate">
<code class="descclassname">mir_eval.separation.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input data to a metric are valid, and throws helpful
errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing true sources</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote class="last">
<div><p>matrix containing estimated sources</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.bss_eval_sources">
<code class="descclassname">mir_eval.separation.</code><code class="descname">bss_eval_sources</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.bss_eval_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>MATLAB translation of BSS_EVAL Toolbox</p>
<p>Ordering and measurement of the separation quality for estimated source
signals in terms of filtered true source, interference and artifacts.</p>
<p>The decomposition allows a time-invariant filter distortion of length
512, as described in Section III.B of <a class="footnote-reference" href="#id7" id="id19">[2]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing true sources</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing estimated sources</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sdr</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Signal to Distortion Ratios (SDR)</p>
</div></blockquote>
<p><strong>sir</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Source to Interference Ratios (SIR)</p>
</div></blockquote>
<p><strong>sar</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote>
<div><p>vector of Sources to Artifacts Ratios (SAR)</p>
</div></blockquote>
<p><strong>perm</strong> : np.ndarray, shape=(nsrc,)</p>
<blockquote class="last">
<div><p>vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number perm[j] corresponds to
true source number j)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">perm</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">bss_eval_sources</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                              <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.evaluate">
<code class="descclassname">mir_eval.separation.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_sources</em>, <em>estimated_sources</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.separation.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing true sources</p>
</div></blockquote>
<p><strong>estimated_sources</strong> : np.ndarray, shape=(nsrc, nsampl)</p>
<blockquote>
<div><p>matrix containing estimated sources</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">estimated_sources</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.tempo">
<span id="mir-eval-tempo"></span><h3><a class="reference internal" href="#module-mir_eval.tempo" title="mir_eval.tempo"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.tempo</span></code></a><a class="headerlink" href="#module-mir_eval.tempo" title="Permalink to this headline">¶</a></h3>
<p>The goal of a tempo estimation algorithm is to automatically detect the tempo
of a piece of music, measured in beats per minute (BPM).</p>
<p>See <a class="reference external" href="http://www.music-ir.org/mirex/wiki/2014:Audio_Tempo_Estimation">http://www.music-ir.org/mirex/wiki/2014:Audio_Tempo_Estimation</a> for a
description of the task and evaluation criteria.</p>
<div class="section" id="id20">
<h4>Conventions<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>Reference tempi should be strictly positive, and provided in ascending order
as a numpy array of length 2.  Estimated tempi are allowed to be 0, but
otherwise are subject to the same constraints as reference.</p>
<p>The weighting value from the reference must be a float in the range [0, 1].</p>
</div>
<div class="section" id="id21">
<h4>Metrics<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.tempo.detection" title="mir_eval.tempo.detection"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.tempo.detection()</span></code></a>: Relative error, hits, and weighted
precision of tempo estimation.</li>
</ul>
<dl class="function">
<dt id="mir_eval.tempo.validate_tempi">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">validate_tempi</code><span class="sig-paren">(</span><em>tempi</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.validate_tempi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="mir_eval.tempo.validate">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_tempi</em>, <em>reference_weight</em>, <em>estimated_tempi</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid tempo
annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_onsets</strong> : np.ndarray</p>
<blockquote>
<div><p>reference tempo values, in bpm</p>
</div></blockquote>
<p><strong>reference_weight</strong> : float</p>
<blockquote>
<div><p>perceptual weight of slow vs fast in reference</p>
</div></blockquote>
<p><strong>estimated_onsets</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>estimated tempo values, in bpm</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.tempo.detection">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">detection</code><span class="sig-paren">(</span><em>reference_tempi</em>, <em>reference_weight</em>, <em>estimated_tempi</em>, <em>tol=0.08</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the tempo detection accuracy metric.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative reference tempi, t_1 and t_2</p>
</div></blockquote>
<p><strong>reference_weight</strong> : float &gt; 0</p>
<blockquote>
<div><p>The relative strength of t_1 vs t_2 in the reference.</p>
</div></blockquote>
<p><strong>estimated_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative estimated tempi, r_1 and r_2.</p>
</div></blockquote>
<p><strong>tol</strong> : float in [0, 1]:</p>
<blockquote>
<div><p>The maximum allowable deviation from a reference tempo to
count as a hit.
<code class="docutils literal"><span class="pre">|est_t</span> <span class="pre">-</span> <span class="pre">ref_t|</span> <span class="pre">&lt;=</span> <span class="pre">tol</span> <span class="pre">*</span> <span class="pre">ref_t</span></code>
(Default value = 0.08)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p_score</strong> : float in [0, 1]</p>
<blockquote>
<div><p>Weighted average of recalls:
<code class="docutils literal"><span class="pre">reference_weight</span> <span class="pre">*</span> <span class="pre">hits[0]</span> <span class="pre">+</span> <span class="pre">(1</span> <span class="pre">-</span> <span class="pre">reference_weight)</span> <span class="pre">*</span> <span class="pre">hits[1]</span></code></p>
</div></blockquote>
<p><strong>one_correct</strong> : bool</p>
<blockquote>
<div><p>True if at least one reference tempo was correctly estimated</p>
</div></blockquote>
<p><strong>both_correct</strong> : bool</p>
<blockquote>
<div><p>True if both reference tempi were correctly estimated</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If the input tempi are ill-formed</p>
<p>If the reference weight is not in the range [0, 1]</p>
<p>If <code class="docutils literal"><span class="pre">tol</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> or <code class="docutils literal"><span class="pre">tol</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.tempo.evaluate">
<code class="descclassname">mir_eval.tempo.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_tempi</em>, <em>reference_weight</em>, <em>estimated_tempi</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.tempo.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative reference tempi, t_slow and t_fast,
such that t_slow &lt; t_fast.</p>
</div></blockquote>
<p><strong>reference_weight</strong> : float &gt; 0</p>
<blockquote>
<div><p>The relative strength of t_slow vs t_fast in the reference.</p>
</div></blockquote>
<p><strong>estimated_tempi</strong> : np.ndarray, shape=(2,)</p>
<blockquote>
<div><p>Two non-negative estimated tempi, r_slow and r_fast.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.transcription">
<span id="mir-eval-transcription"></span><h3><a class="reference internal" href="#module-mir_eval.transcription" title="mir_eval.transcription"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.transcription</span></code></a><a class="headerlink" href="#module-mir_eval.transcription" title="Permalink to this headline">¶</a></h3>
<p>The aim of a transcription algorithm is to produce a symbolic representation of
a recorded piece of music in the form of a set of discrete notes. There are
different ways to represent notes symbolically. Here we use the piano-roll
convention, meaning each note has a start time, a duration (or end time), and
a single, constant, pitch value. Pitch values can be quantized (e.g. to a
semitone grid tuned to 440 Hz), but do not have to be. Also, the transcription
can contain the notes of a single instrument or voice (for example the melody),
or the notes of all instruments/voices in the recording. This module is
instrument agnostic: all notes in the estimate are compared against all notes
in the reference.</p>
<p>There are many metrics for evaluating transcription algorithms. Here we limit
ourselves to the most simple and commonly used: given two sets of notes, we
count how many estimate notes match the reference, and how many do not. Based
on these counts we compute the precision, recall, and f-measure of the estimate
given the reference. The default criteria for considering two notes to be a
match are adopted from the <a class="reference external" href="http://www.music-ir.org/mirex/wiki/2015:Multiple_Fundamental_Frequency_Estimation_%26_Tracking_Results_-_MIREX_Dataset#Task_2:Note_Tracking_.28NT.29">MIREX Multiple fundamental frequency estimation and
tracking, Note Tracking subtask (task 2)</a>:</p>
<p>&#8220;This subtask is evaluated in two different ways. In the first setup , a
returned note is assumed correct if its onset is within +-50ms of a ref note
and its F0 is within +- quarter tone of the corresponding reference note,
ignoring the returned offset values. In the second setup, on top of the above
requirements, a correct returned note is required to have an offset value
within 20% of the ref notes duration around the ref note&#8217;s offset, or within
50ms whichever is larger.&#8221;</p>
<p>In short, we compute precision, recall and f-measure, once without taking
offsets into account, and the second time with.</p>
<p>For further details see Salamon, 2013 (page 186), and references therein:</p>
<blockquote>
<div>Salamon, J. (2013). Melody Extraction from Polyphonic Music Signals.
Ph.D. thesis, Universitat Pompeu Fabra, Barcelona, Spain, 2013.</div></blockquote>
<p>IMPORTANT NOTE: the evaluation code in <code class="docutils literal"><span class="pre">mir_eval</span></code> contains several important
differences with respect to the code used in MIREX 2015 for the Note Tracking
subtask on the Su dataset (henceforth &#8220;MIREX&#8221;):</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">mir_eval</span></code> uses bipartite graph matching to find the optimal pairing of
reference notes to estimated notes. MIREX uses a greedy matching algorithm,
which can produce sub-optimal note matching. This will result in
<code class="docutils literal"><span class="pre">mir_eval</span></code>&#8216;s metrics being slightly higher compared to MIREX.</li>
<li>MIREX rounds down the onset and offset times of each note to 2 decimal
points using <code class="docutils literal"><span class="pre">new_time</span> <span class="pre">=</span> <span class="pre">0.01</span> <span class="pre">*</span> <span class="pre">floor(time*100)</span></code>. <code class="docutils literal"><span class="pre">mir_eval</span></code> doesn&#8217;t
modify the note onset and offset times. This will bring our metrics down a
notch compared to the MIREX results.</li>
<li>In the MIREX wiki, the criterion for matching offsets is that they must be
within 0.2 * ref_duration <strong>or 0.05 from each other, whichever is greater</strong>
(i.e. <code class="docutils literal"><span class="pre">offset_dif</span> <span class="pre">&lt;=</span> <span class="pre">max(0.2</span> <span class="pre">*</span> <span class="pre">ref_duration,</span> <span class="pre">0.05)</span></code>. The MIREX code
however only uses a threshold of 0.2 * ref_duration, without the 0.05
minimum. Since <code class="docutils literal"><span class="pre">mir_eval</span></code> does include this minimum, it might produce
slightly higher results compared to MIREX.</li>
</ol>
<p>This means that differences 1 and 3 bring <code class="docutils literal"><span class="pre">mir_eval</span></code>&#8216;s metrics up compared to
MIREX, whilst 2 brings them down. Based on internal testing, overall the effect
of these three differences is that the Precision, Recall and F-measure returned
by <code class="docutils literal"><span class="pre">mir_eval</span></code> will be higher compared to MIREX by about 1%-2%.</p>
<p>Finally, note that different evaluation scripts have been used for the Multi-F0
Note Tracking task in MIREX over the years. In particular, some scripts used
<code class="docutils literal"><span class="pre">&lt;</span></code> for matching onsets, offsets, and pitch values, whilst the others used
<code class="docutils literal"><span class="pre">&lt;=</span></code> for these checks. <code class="docutils literal"><span class="pre">mir_eval</span></code> provides both options: by default the
latter (<code class="docutils literal"><span class="pre">&lt;=</span></code>) is used, but you can set <code class="docutils literal"><span class="pre">strict=True</span></code> when calling
<a class="reference internal" href="#mir_eval.transcription.precision_recall_f1" title="mir_eval.transcription.precision_recall_f1"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.precision_recall_f1()</span></code></a> in which case <code class="docutils literal"><span class="pre">&lt;</span></code> will
be used. The default value (<code class="docutils literal"><span class="pre">strict=False</span></code>) is the same as that used in
MIREX 2015 for the Note Tracking subtask on the Su dataset.</p>
<div class="section" id="id22">
<h4>Conventions<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>Notes should be provided in the form of an interval array and a pitch array.
The interval array contains two columns, one for note onsets and the second
for note offsets (each row represents a single note). The pitch array contains
one column with the corresponding note pitch values (one value per note),
represented by their fundamental frequency (f0) in Hertz.</p>
</div>
<div class="section" id="id23">
<h4>Metrics<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.transcription.precision_recall_f1" title="mir_eval.transcription.precision_recall_f1"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.transcription.precision_recall_f1()</span></code></a>: The precision,
recall, and F-measure of the note transcription, where an estimated note is
considered correct if its pitch, onset and (optionally) offset are
sufficiently close to a reference note</li>
</ul>
<dl class="function">
<dt id="mir_eval.transcription.validate">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like time intervals
and a pitch list, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches: np.ndarray, shape=(n,)</strong></p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote class="last">
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.match_notes">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">match_notes</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>onset_tolerance=0.05</em>, <em>pitch_tolerance=50.0</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.match_notes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated notes,
subject to onset, pitch and (optionally) offset constraints.</p>
<p>Given two note sequences represented by <code class="docutils literal"><span class="pre">ref_intervals</span></code>, <code class="docutils literal"><span class="pre">ref_pitches</span></code>,
<code class="docutils literal"><span class="pre">est_intervals</span></code> and <code class="docutils literal"><span class="pre">est_pitches</span></code>
(see <a class="reference internal" href="#mir_eval.io.load_valued_intervals" title="mir_eval.io.load_valued_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_valued_intervals()</span></code></a>), we seek the largest set
of correspondences <code class="docutils literal"><span class="pre">(i,</span> <span class="pre">j)</span></code> such that:</p>
<ol class="arabic simple">
<li>The onset of ref note i is within <code class="docutils literal"><span class="pre">onset_tolerance</span></code> of the onset of
est note j.</li>
<li>The pitch of ref note i is within <code class="docutils literal"><span class="pre">pitch_tolerance</span></code> of the pitch of
est note j.</li>
<li>If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is not <code class="docutils literal"><span class="pre">None</span></code>, the offset of ref note i has to be
within <code class="docutils literal"><span class="pre">offset_tolerance</span></code> of the offset of est note j, where
<code class="docutils literal"><span class="pre">offset_tolerance</span></code> is equal to <code class="docutils literal"><span class="pre">offset_ratio</span></code> times the ref note&#8217;s
duration, i.e. <code class="docutils literal"><span class="pre">offset_ratio</span> <span class="pre">*</span> <span class="pre">ref_duration[i]</span></code> where
<code class="docutils literal"><span class="pre">ref_duration[i]</span> <span class="pre">=</span> <span class="pre">ref_intervals[i,</span> <span class="pre">1]</span> <span class="pre">-</span> <span class="pre">ref_intervals[i,</span> <span class="pre">0]</span></code>. If the
resulting <code class="docutils literal"><span class="pre">offset_tolerance</span></code> is less than 0.05 (50 ms), 0.05 is used
instead.</li>
<li>If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, note offsets are ignored, and only
criteria 1 and 2 are taken into consideration.</li>
</ol>
<p>Every ref note is matched against at most one est note.</p>
<p>This is useful for computing precision/recall metrics for note
transcription.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches: np.ndarray, shape=(n,)</strong></p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note&#8217;s onset deviating from the
reference note&#8217;s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>pitch_tolerance: float &gt; 0</strong></p>
<blockquote>
<div><p>The tolerance for an estimated note&#8217;s pitch deviating from the
reference note&#8217;s pitch, in cents. Default is 50.0 (50 cents).</p>
</div></blockquote>
<p><strong>offset_ratio: float &gt; 0 or None</strong></p>
<blockquote>
<div><p>The ratio of the reference note&#8217;s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the offset_tolerance
will equal the ref_duration * 0.2, or 0.05 (50 ms), whichever is
greater. If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is set to <code class="docutils literal"><span class="pre">None</span></code>, offsets are ignored in
the matching.</p>
</div></blockquote>
<p><strong>offset_min_tolerance: float &gt; 0</strong></p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See offset_ratio description
for an explanation of how the offset tolerance is determined. Note:
this parameter only influences the results if <code class="docutils literal"><span class="pre">offset_ratio</span></code> is not
<code class="docutils literal"><span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>strict: bool</strong></p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less
than).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matching</strong> : list of tuples</p>
<blockquote class="last">
<div><p>A list of matched reference and estimated notes.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where reference note i matches estimate note
j.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.precision_recall_f1">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">precision_recall_f1</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>onset_tolerance=0.05</em>, <em>pitch_tolerance=50.0</em>, <em>offset_ratio=0.2</em>, <em>offset_min_tolerance=0.05</em>, <em>strict=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.precision_recall_f1" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Precision, Recall and F-measure of correct vs incorrectly
transcribed notes. &#8220;Correctness&#8221; is determined based on note onset, pitch
and (optionally) offset: an estimated note is assumed correct if its onset
is within +-50ms of a ref note and its pitch (F0) is within +- quarter tone
(50 cents) of the corresponding reference note. If with_offset is False,
note offsets are ignored in the comparison. It with_offset is True,
on top of the above requirements, a correct returned note is required to
have an offset value within 20% (by default, adjustable via the
offset_ratio parameter) of the ref note&#8217;s duration around the ref note&#8217;s
offset, or within offset_min_tolerance (50 ms by default), whichever is
larger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches: np.ndarray, shape=(n,)</strong></p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>onset_tolerance</strong> : float &gt; 0</p>
<blockquote>
<div><p>The tolerance for an estimated note&#8217;s onset deviating from the
reference note&#8217;s onset, in seconds. Default is 0.05 (50 ms).</p>
</div></blockquote>
<p><strong>pitch_tolerance: float &gt; 0</strong></p>
<blockquote>
<div><p>The tolerance for an estimated note&#8217;s pitch deviating from the
reference note&#8217;s pitch, in cents. Default is 50.0 (50 cents).</p>
</div></blockquote>
<p><strong>offset_ratio: float &gt; 0 or None</strong></p>
<blockquote>
<div><p>The ratio of the reference note&#8217;s duration used to define the
offset_tolerance. Default is 0.2 (20%), meaning the offset_tolerance
will equal the ref_duration * 0.2, or min_offset_tolerance (0.05 by
default, i.e. 50 ms), whichever is greater. If <code class="docutils literal"><span class="pre">offset_ratio</span></code> is set
to <code class="docutils literal"><span class="pre">None</span></code>, offsets are ignored in the evaluation.</p>
</div></blockquote>
<p><strong>offset_min_tolerance: float &gt; 0</strong></p>
<blockquote>
<div><p>The minimum tolerance for offset matching. See offset_ratio description
for an explanation of how the offset tolerance is determined. Note:
this parameter only influences the results if offset_ratio is not
<code class="docutils literal"><span class="pre">None</span></code>.</p>
</div></blockquote>
<p><strong>strict: bool</strong></p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">strict=False</span></code> (the default), threshold checks for onset, offset,
and pitch matching are performed using <code class="docutils literal"><span class="pre">&lt;=</span></code> (less than or equal). If
<code class="docutils literal"><span class="pre">strict=True</span></code>, the threshold checks are performed using <code class="docutils literal"><span class="pre">&lt;</span></code> (less
than).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>precision</strong> : float</p>
<blockquote>
<div><p>The computed precision score</p>
</div></blockquote>
<p><strong>recall</strong> : float</p>
<blockquote>
<div><p>The computed recall score</p>
</div></blockquote>
<p><strong>f_measure</strong> : float</p>
<blockquote class="last">
<div><p>The computed F-measure score</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">precision</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">recall</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">f_measure</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">precision_recall_f1</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">precision_no_offset</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">recall_no_offset</span><span class="p">,</span>
<span class="gp">... </span> <span class="n">f_measure_no_offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">precision_recall_f1</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span> <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">offset_ratio</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.transcription.evaluate">
<code class="descclassname">mir_eval.transcription.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>ref_intervals</em>, <em>ref_pitches</em>, <em>est_intervals</em>, <em>est_pitches</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.transcription.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_intervals</strong> : np.ndarray, shape=(n,2)</p>
<blockquote>
<div><p>Array of reference notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>ref_pitches: np.ndarray, shape=(n,)</strong></p>
<blockquote>
<div><p>Array of reference pitch values in Hertz</p>
</div></blockquote>
<p><strong>est_intervals</strong> : np.ndarray, shape=(m,2)</p>
<blockquote>
<div><p>Array of estimated notes time intervals (onset and offset times)</p>
</div></blockquote>
<p><strong>est_pitches</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated pitch values in Hertz</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_valued_intervals</span><span class="p">(</span>
<span class="gp">... </span>   <span class="s1">&#39;estimate.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_pitches</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_pitches</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.key">
<span id="mir-eval-key"></span><h3><a class="reference internal" href="#module-mir_eval.key" title="mir_eval.key"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.key</span></code></a><a class="headerlink" href="#module-mir_eval.key" title="Permalink to this headline">¶</a></h3>
<p>Key Detection involves determining the underlying key (distribution of notes
and note transitions) in a piece of music.  Key detection algorithms are
evaluated by comparing their estimated key to a ground-truth reference key and
reporting a score according to the relationship of the keys.</p>
<div class="section" id="id24">
<h4>Conventions<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>Keys are represented as strings of the form <code class="docutils literal"><span class="pre">'(key)</span> <span class="pre">(mode)'</span></code>, e.g. <code class="docutils literal"><span class="pre">'C#</span>
<span class="pre">major'</span></code> or <code class="docutils literal"><span class="pre">'Fb</span> <span class="pre">minor'</span></code>.  The case of the key is ignored.  Note that certain
key strings are equivalent, e.g. <code class="docutils literal"><span class="pre">'C#</span> <span class="pre">major'</span></code> and <code class="docutils literal"><span class="pre">'Db</span> <span class="pre">major'</span></code>.  The mode
may only be specified as either <code class="docutils literal"><span class="pre">'major'</span></code> or <code class="docutils literal"><span class="pre">'minor'</span></code>, no other mode
strings will be accepted.</p>
</div>
<div class="section" id="id25">
<h4>Metrics<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.key.weighted_score" title="mir_eval.key.weighted_score"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.key.weighted_score()</span></code></a>: Heuristic scoring of the relation of two
keys.</li>
</ul>
<dl class="function">
<dt id="mir_eval.key.validate_key">
<code class="descclassname">mir_eval.key.</code><code class="descname">validate_key</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.validate_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a key is well-formatted, e.g. in the form <code class="docutils literal"><span class="pre">'C#</span> <span class="pre">major'</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : str</p>
<blockquote class="last">
<div><p>Key to verify</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.validate">
<code class="descclassname">mir_eval.key.</code><code class="descname">validate</code><span class="sig-paren">(</span><em>reference_key</em>, <em>estimated_key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric are valid key strings and
throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_key</strong> : str</p>
<blockquote>
<div><p>Reference key string.</p>
</div></blockquote>
<p><strong>estimated_key</strong> : str</p>
<blockquote class="last">
<div><p>Estimated key string.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.split_key_string">
<code class="descclassname">mir_eval.key.</code><code class="descname">split_key_string</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.split_key_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a key string (of the form, e.g. <code class="docutils literal"><span class="pre">'C#</span> <span class="pre">major'</span></code>), into a tuple of
<code class="docutils literal"><span class="pre">(key,</span> <span class="pre">mode)</span></code> where <code class="docutils literal"><span class="pre">key</span></code> is is an integer representing the semitone
distance from C.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : str</p>
<blockquote>
<div><p>String representing a key.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>key</strong> : int</p>
<blockquote>
<div><p>Number of semitones above C.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote class="last">
<div><p>String representing the mode.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.weighted_score">
<code class="descclassname">mir_eval.key.</code><code class="descname">weighted_score</code><span class="sig-paren">(</span><em>reference_key</em>, <em>estimated_key</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.weighted_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a heuristic score which is weighted according to the
relationship of the reference and estimated key, as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="89%" />
<col width="11%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Relationship</td>
<td>Score</td>
</tr>
<tr class="row-even"><td>Same key</td>
<td>1.0</td>
</tr>
<tr class="row-odd"><td>Estimated key is a perfect fifth above reference key</td>
<td>0.5</td>
</tr>
<tr class="row-even"><td>Relative major/minor</td>
<td>0.3</td>
</tr>
<tr class="row-odd"><td>Parallel major/minor</td>
<td>0.2</td>
</tr>
<tr class="row-even"><td>Other</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reference_key</strong> : str</p>
<blockquote>
<div><p>Reference key string.</p>
</div></blockquote>
<p><strong>estimated_key</strong> : str</p>
<blockquote>
<div><p>Estimated key string.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>Score representing how closely related the keys are.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">weighted_score</span><span class="p">(</span><span class="n">ref_key</span><span class="p">,</span> <span class="n">est_key</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.key.evaluate">
<code class="descclassname">mir_eval.key.</code><code class="descname">evaluate</code><span class="sig-paren">(</span><em>reference_key</em>, <em>estimated_key</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.key.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_key</strong> : str</p>
<blockquote>
<div><p>Reference key string.</p>
</div></blockquote>
<p><strong>ref_key</strong> : str</p>
<blockquote>
<div><p>Estimated key string.</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : dict</p>
<blockquote class="last">
<div><p>Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_key</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_key</span><span class="p">(</span><span class="s1">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_key</span><span class="p">,</span> <span class="n">est_key</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.util">
<span id="mir-eval-util"></span><h3><a class="reference internal" href="#module-mir_eval.util" title="mir_eval.util"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.util</span></code></a><a class="headerlink" href="#module-mir_eval.util" title="Permalink to this headline">¶</a></h3>
<p>This submodule collects useful functionality required across the task
submodules, such as preprocessing, validation, and common computations.</p>
<dl class="function">
<dt id="mir_eval.util.index_labels">
<code class="descclassname">mir_eval.util.</code><code class="descname">index_labels</code><span class="sig-paren">(</span><em>labels</em>, <em>case_sensitive=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.index_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of string identifiers into numerical indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of strings, shape=(n,)</p>
<blockquote>
<div><p>A list of annotations, e.g., segment or chord labels from an
annotation file.</p>
</div></blockquote>
<p><strong>case_sensitive</strong> : bool</p>
<blockquote>
<div><p>Set to True to enable case-sensitive label indexing
(Default value = False)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>indices</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>Numerical representation of <em>labels</em></p>
</div></blockquote>
<p><strong>index_to_label</strong> : dict</p>
<blockquote class="last">
<div><p>Mapping to convert numerical indices back to labels.
<code class="docutils literal"><span class="pre">labels[i]</span> <span class="pre">==</span> <span class="pre">index_to_label[indices[i]]</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.generate_labels">
<code class="descclassname">mir_eval.util.</code><code class="descname">generate_labels</code><span class="sig-paren">(</span><em>items</em>, <em>prefix='__'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.generate_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array of items (e.g. events, intervals), create a synthetic label
for each event of the form &#8216;(label prefix)(item number)&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>items</strong> : list-like</p>
<blockquote>
<div><p>A list or array of events or intervals</p>
</div></blockquote>
<p><strong>prefix</strong> : str</p>
<blockquote>
<div><p>This prefix will be prepended to all synthetically generated labels
(Default value = &#8216;__&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>labels</strong> : list of str</p>
<blockquote class="last">
<div><p>Synthetically generated labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_samples">
<code class="descclassname">mir_eval.util.</code><code class="descname">intervals_to_samples</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels</em>, <em>offset=0</em>, <em>sample_size=0.1</em>, <em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of labeled time intervals to annotated samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, d)</p>
<blockquote>
<div><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></code></a>.
The <code class="docutils literal"><span class="pre">i</span></code> th interval spans time <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>The annotation for each interval</p>
</div></blockquote>
<p><strong>offset</strong> : float &gt; 0</p>
<blockquote>
<div><p>Phase offset of the sampled time grid (in seconds)
(Default value = 0)</p>
</div></blockquote>
<p><strong>sample_size</strong> : float &gt; 0</p>
<blockquote>
<div><p>duration of each sample to be generated (in seconds)
(Default value = 0.1)</p>
</div></blockquote>
<p><strong>fill_value</strong> : type(labels[0])</p>
<blockquote>
<div><p>Object to use for the label with out-of-range time points.
(Default value = None)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sample_times</strong> : list</p>
<blockquote>
<div><p>list of sample times</p>
</div></blockquote>
<p><strong>sample_labels</strong> : list</p>
<blockquote>
<div><p>array of labels for each generated sample</p>
</div></blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Intervals will be rounded down to the nearest multiple
of <code class="docutils literal"><span class="pre">sample_size</span></code>.</p>
</div>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.interpolate_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">interpolate_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels</em>, <em>time_points</em>, <em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.interpolate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign labels to a set of points in time given a set of intervals.</p>
<p>Note: Times outside of the known boundaries are mapped to None by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, d)</p>
<blockquote>
<div><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a>.
The <code class="docutils literal"><span class="pre">i</span></code> th interval spans time <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
</div></blockquote>
<p><strong>labels</strong> : list, shape=(n,)</p>
<blockquote>
<div><p>The annotation for each interval</p>
</div></blockquote>
<p><strong>time_points</strong> : array_like, shape=(m,)</p>
<blockquote>
<div><p>Points in time to assign labels.</p>
</div></blockquote>
<p><strong>fill_value</strong> : type(labels[0])</p>
<blockquote>
<div><p>Object to use for the label with out-of-range time points.
(Default value = None)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aligned_labels</strong> : list</p>
<blockquote class="last">
<div><p>Labels corresponding to the given time points.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.f_measure">
<code class="descclassname">mir_eval.util.</code><code class="descname">f_measure</code><span class="sig-paren">(</span><em>precision</em>, <em>recall</em>, <em>beta=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the f-measure from precision and recall scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>precision</strong> : float in (0, 1]</p>
<blockquote>
<div><p>Precision</p>
</div></blockquote>
<p><strong>recall</strong> : float in (0, 1]</p>
<blockquote>
<div><p>Recall</p>
</div></blockquote>
<p><strong>beta</strong> : float &gt; 0</p>
<blockquote>
<div><p>Weighting factor for f-measure
(Default value = 1.0)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f_measure</strong> : float</p>
<blockquote class="last">
<div><p>The weighted f-measure</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_boundaries">
<code class="descclassname">mir_eval.util.</code><code class="descname">intervals_to_boundaries</code><span class="sig-paren">(</span><em>intervals</em>, <em>q=5</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert interval times into boundaries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>Array of interval start and end-times</p>
</div></blockquote>
<p><strong>q</strong> : int</p>
<blockquote>
<div><p>Number of decimals to round to. (Default value = 5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>boundaries</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Interval boundary times, including the end of the final interval</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.boundaries_to_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">boundaries_to_intervals</code><span class="sig-paren">(</span><em>boundaries</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.boundaries_to_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of event times into intervals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>boundaries</strong> : list-like</p>
<blockquote>
<div><p>List-like of event times.  These are assumed to be unique
timestamps in ascending order.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_intervals, 2)</p>
<blockquote class="last">
<div><p>Start and end time for each interval</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.adjust_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">adjust_intervals</code><span class="sig-paren">(</span><em>intervals</em>, <em>labels=None</em>, <em>t_min=0.0</em>, <em>t_max=None</em>, <em>start_label='__T_MIN'</em>, <em>end_label='__T_MAX'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.adjust_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust a list of time intervals to span the range [t_min, t_max].</p>
<p>Any intervals lying completely outside the specified range will be removed.</p>
<p>Any intervals lying partially outside the specified range will be cropped.</p>
<p>If the specified range exceeds the span of the provided data in either
direction, additional intervals will be appended.  If an interval is
appended at the beginning, it will be given the label <code class="docutils literal"><span class="pre">start_label</span></code>; if
an interval is appended at the end, it will be given the label
<code class="docutils literal"><span class="pre">end_label</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>Array of interval start and end-times</p>
</div></blockquote>
<p><strong>labels</strong> : list, len=n_events or None</p>
<blockquote>
<div><p>List of labels
(Default value = None)</p>
</div></blockquote>
<p><strong>t_min</strong> : float or None</p>
<blockquote>
<div><p>Minimum interval start time.
(Default value = 0.0)</p>
</div></blockquote>
<p><strong>t_max</strong> : float or None</p>
<blockquote>
<div><p>Maximum interval end time.
(Default value = None)</p>
</div></blockquote>
<p><strong>start_label</strong> : str or float or int</p>
<blockquote>
<div><p>Label to give any intervals appended at the beginning
(Default value = &#8216;__T_MIN&#8217;)</p>
</div></blockquote>
<p><strong>end_label</strong> : str or float or int</p>
<blockquote>
<div><p>Label to give any intervals appended at the end
(Default value = &#8216;__T_MAX&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>Intervals spanning [t_min, t_max]</p>
</div></blockquote>
<p><strong>new_labels</strong> : list</p>
<blockquote class="last">
<div><p>List of labels for new_labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.adjust_events">
<code class="descclassname">mir_eval.util.</code><code class="descname">adjust_events</code><span class="sig-paren">(</span><em>events</em>, <em>labels=None</em>, <em>t_min=0.0</em>, <em>t_max=None</em>, <em>label_prefix='__'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.adjust_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the given list of event times to span the range [t_min, t_max].</p>
<p>Any event times outside of the specified range will be removed.</p>
<p>If the times do not span [t_min, t_max], additional events will be added
with the prefix <code class="docutils literal"><span class="pre">label_prefix</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of event times (seconds)</p>
</div></blockquote>
<p><strong>labels</strong> : list or None</p>
<blockquote>
<div><p>List of labels
(Default value = None)</p>
</div></blockquote>
<p><strong>t_min</strong> : float or None</p>
<blockquote>
<div><p>Minimum valid event time.
(Default value = 0.0)</p>
</div></blockquote>
<p><strong>t_max</strong> : float or None</p>
<blockquote>
<div><p>Maximum valid event time.
(Default value = None)</p>
</div></blockquote>
<p><strong>label_prefix</strong> : str</p>
<blockquote>
<div><p>Prefix string to use for synthetic labels
(Default value = &#8216;__&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_times</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Event times corrected to the given range.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intersect_files">
<code class="descclassname">mir_eval.util.</code><code class="descname">intersect_files</code><span class="sig-paren">(</span><em>flist1</em>, <em>flist2</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intersect_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of two sets of filepaths, based on the file name
(after the final &#8216;/&#8217;) and ignoring the file extension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>flist1</strong> : list</p>
<blockquote>
<div><p>first list of filepaths</p>
</div></blockquote>
<p><strong>flist2</strong> : list</p>
<blockquote>
<div><p>second list of filepaths</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sublist1</strong> : list</p>
<blockquote>
<div><p>subset of filepaths with matching stems from <em>flist1</em></p>
</div></blockquote>
<p><strong>sublist2</strong> : list</p>
<blockquote class="last">
<div><p>corresponding filepaths from <em>flist2</em></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flist1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/a/b/abc.lab&#39;</span><span class="p">,</span> <span class="s1">&#39;/c/d/123.lab&#39;</span><span class="p">,</span> <span class="s1">&#39;/e/f/xyz.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flist2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;/g/h/xyz.npy&#39;</span><span class="p">,</span> <span class="s1">&#39;/i/j/123.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;/k/l/456.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sublist1</span><span class="p">,</span> <span class="n">sublist2</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intersect_files</span><span class="p">(</span><span class="n">flist1</span><span class="p">,</span> <span class="n">flist2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sublist1</span>
<span class="go">[&#39;/e/f/xyz.lab&#39;, &#39;/c/d/123.lab&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sublist2</span>
<span class="go">[&#39;/g/h/xyz.npy&#39;, &#39;/i/j/123.txt&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.merge_labeled_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">merge_labeled_intervals</code><span class="sig-paren">(</span><em>x_intervals</em>, <em>x_labels</em>, <em>y_intervals</em>, <em>y_labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.merge_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the time intervals of two sequences.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of interval times (seconds)</p>
</div></blockquote>
<p><strong>x_labels</strong> : list or None</p>
<blockquote>
<div><p>List of labels</p>
</div></blockquote>
<p><strong>y_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of interval times (seconds)</p>
</div></blockquote>
<p><strong>y_labels</strong> : list or None</p>
<blockquote>
<div><p>List of labels</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>new_intervals</strong> : np.ndarray</p>
<blockquote>
<div><p>New interval times of the merged sequences.</p>
</div></blockquote>
<p><strong>new_x_labels</strong> : list</p>
<blockquote>
<div><p>New labels for the sequence <em>x</em></p>
</div></blockquote>
<p><strong>new_y_labels</strong> : list</p>
<blockquote class="last">
<div><p>New labels for the sequence <em>y</em></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.match_events">
<code class="descclassname">mir_eval.util.</code><code class="descname">match_events</code><span class="sig-paren">(</span><em>ref</em>, <em>est</em>, <em>window</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.match_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated event times,
subject to a window constraint.</p>
<p>Given two lists of event times <code class="docutils literal"><span class="pre">ref</span></code> and <code class="docutils literal"><span class="pre">est</span></code>, we seek the largest set
of correspondences <code class="docutils literal"><span class="pre">(ref[i],</span> <span class="pre">est[j])</span></code> such that <code class="docutils literal"><span class="pre">|ref[i]</span> <span class="pre">-</span> <span class="pre">est[j]|</span> <span class="pre">&lt;=</span>
<span class="pre">window</span></code>, and each <code class="docutils literal"><span class="pre">ref[i]</span></code> and <code class="docutils literal"><span class="pre">est[j]</span></code> is matched at most once.</p>
<p>This is useful for computing precision/recall metrics in beat tracking,
onset detection, and segmentation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of reference event times</p>
</div></blockquote>
<p><strong>est</strong> : np.ndarray, shape=(m,)</p>
<blockquote>
<div><p>Array of estimated event times</p>
</div></blockquote>
<p><strong>window</strong> : float &gt; 0</p>
<blockquote>
<div><p>Size of the window.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matching</strong> : list of tuples</p>
<blockquote class="last">
<div><p>A list of matched reference and event numbers.
<code class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></code> where <code class="docutils literal"><span class="pre">ref[i]</span></code> matches <code class="docutils literal"><span class="pre">est[j]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.validate_intervals">
<code class="descclassname">mir_eval.util.</code><code class="descname">validate_intervals</code><span class="sig-paren">(</span><em>intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that an (n, 2) interval ndarray is well-formed, and raises errors
if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote class="last">
<div><p>Array of interval start/end locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.validate_events">
<code class="descclassname">mir_eval.util.</code><code class="descname">validate_events</code><span class="sig-paren">(</span><em>events</em>, <em>max_time=30000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.validate_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a 1-d event location ndarray is well-formed, and raises
errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : np.ndarray, shape=(n,)</p>
<blockquote>
<div><p>Array of event times</p>
</div></blockquote>
<p><strong>max_time</strong> : float</p>
<blockquote class="last">
<div><p>If an event is found above this time, a ValueError will be raised.
(Default value = 30000.)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.has_kwargs">
<code class="descclassname">mir_eval.util.</code><code class="descname">has_kwargs</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.has_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a function has **kwargs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>function</strong> : callable</p>
<blockquote>
<div><p>The function to test</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if function accepts arbitrary keyword arguments.</p>
<p class="last">False otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.filter_kwargs">
<code class="descclassname">mir_eval.util.</code><code class="descname">filter_kwargs</code><span class="sig-paren">(</span><em>_function</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.filter_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a function and args and keyword args to pass to it, call the function
but using only the keyword arguments which it accepts.  This is equivalent
to redefining the function with an additional **kwargs to accept slop
keyword args.</p>
<p>If the target function already accepts **kwargs parameters, no filtering
is performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>_function</strong> : callable</p>
<blockquote class="last">
<div><p>Function to call.  Can take in any number of args or kwargs</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_durations">
<code class="descclassname">mir_eval.util.</code><code class="descname">intervals_to_durations</code><span class="sig-paren">(</span><em>intervals</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.util.intervals_to_durations" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an array of n intervals to their n durations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n, 2)</p>
<blockquote>
<div><p>An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></code></a>.
The <em>i</em> th interval spans time <code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></code> to
<code class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>durations</strong> : np.ndarray, shape=(n,)</p>
<blockquote class="last">
<div><p>Array of the duration of each interval.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mir_eval.io">
<span id="mir-eval-io"></span><h3><a class="reference internal" href="#module-mir_eval.io" title="mir_eval.io"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.io</span></code></a><a class="headerlink" href="#module-mir_eval.io" title="Permalink to this headline">¶</a></h3>
<p>Functions for loading in annotations from files in different formats.</p>
<dl class="function">
<dt id="mir_eval.io.load_delimited">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_delimited</code><span class="sig-paren">(</span><em>filename</em>, <em>converters</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_delimited" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for loading in data from an annotation file where columns
are delimited.  The number of columns is inferred from the length of
the provided converters list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>converters</strong> : list of functions</p>
<blockquote>
<div><p>Each entry in column <code class="docutils literal"><span class="pre">n</span></code> of the file will be cast by the function
<code class="docutils literal"><span class="pre">converters[n]</span></code>.</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>columns</strong> : tuple of lists</p>
<blockquote class="last">
<div><p>Each list in this tuple corresponds to values in one of the columns
in the file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load in a one-column list of event times (floats)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s1">&#39;events.txt&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load in a list of labeled events, separated by commas</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s1">&#39;labeled_events.csv&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="s1">&#39;,&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_events">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_events</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import time-stamp events from an annotation file.  The file should
consist of a single column of numeric values corresponding to the event
times. This is primarily useful for processing events which lack duration,
such as beats or onsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>event_times</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>array of event times (float)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_labeled_events">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_labeled_events</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_labeled_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled time-stamp events from an annotation file.  The file should
consist of two columns; the first having numeric values corresponding to
the event times and the second having string labels for each event.  This
is primarily useful for processing labeled events which lack duration, such
as beats with metric beat number or onsets with an instrument label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>event_times</strong> : np.ndarray</p>
<blockquote>
<div><p>array of event times (float)</p>
</div></blockquote>
<p><strong>labels</strong> : list of str</p>
<blockquote class="last">
<div><p>list of labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_intervals">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_intervals</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import intervals from an annotation file.  The file should consist of two
columns of numeric values corresponding to start and end time of each
interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote class="last">
<div><p>array of event start and end times</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_labeled_intervals">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_labeled_intervals</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled intervals from an annotation file.  The file should consist
of three columns: Two consisting of numeric values corresponding to start
and end time of each interval and a third corresponding to the label of
each interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>array of event start and end time</p>
</div></blockquote>
<p><strong>labels</strong> : list of str</p>
<blockquote class="last">
<div><p>list of labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_time_series">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_time_series</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Import a time series from an annotation file.  The file should consist of
two columns of numeric values corresponding to the time and value of each
sample of the time series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>array of timestamps (float)</p>
</div></blockquote>
<p><strong>values</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>array of corresponding numeric values (float)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_patterns">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_patterns</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_patterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the patters contained in the filename and puts them into a list
of patterns, each pattern being a list of occurrence, and each
occurrence being a list of (onset, midi) pairs.</p>
<p>The input file must be formatted as described in MIREX 2013:
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>The input file path containing the patterns of a given piece using the
MIREX 2013 format.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pattern_list</strong> : list</p>
<blockquote class="last">
<div><p>The list of patterns, containing all their occurrences,
using the following format:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">onset_midi</span> <span class="o">=</span> <span class="p">(</span><span class="n">onset_time</span><span class="p">,</span> <span class="n">midi_number</span><span class="p">)</span>
<span class="n">occurrence</span> <span class="o">=</span> <span class="p">[</span><span class="n">onset_midi1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">onset_midiO</span><span class="p">]</span>
<span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">occurrence1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">occurrenceM</span><span class="p">]</span>
<span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pattern1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">patternN</span><span class="p">]</span>
</pre></div>
</div>
<p>where <cite>N</cite> is the number of patterns, <cite>M[i]</cite> is the number of
occurrences of the <cite>i</cite>&#8216;th pattern, and <cite>O[j]</cite> is the number of onsets
in the <cite>j</cite>&#8216;th occurrence.  E.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">occ1</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">64.0</span><span class="p">)]</span>
<span class="n">occ2</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.5</span><span class="p">,</span> <span class="mf">65.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">6.0</span><span class="p">,</span> <span class="mf">62.0</span><span class="p">)]</span>
<span class="n">pattern1</span> <span class="o">=</span> <span class="p">[</span><span class="n">occ1</span><span class="p">,</span> <span class="n">occ2</span><span class="p">]</span>

<span class="n">occ1</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">10.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">11.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">11.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">64.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">12.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">13.0</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">13.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">14.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.0</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.5</span><span class="p">,</span> <span class="mf">76.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">16.0</span><span class="p">,</span> <span class="mf">72.0</span><span class="p">)]</span>
<span class="n">occ2</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">19.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">19.5</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">62.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">20.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">21.0</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">21.5</span><span class="p">,</span> <span class="mf">69.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">22.0</span><span class="p">,</span> <span class="mf">67.0</span><span class="p">),</span>
        <span class="p">(</span><span class="mf">22.5</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">23.0</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">23.5</span><span class="p">,</span> <span class="mf">77.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">24.0</span><span class="p">,</span> <span class="mf">74.0</span><span class="p">)]</span>
<span class="n">pattern2</span> <span class="o">=</span> <span class="p">[</span><span class="n">occ1</span><span class="p">,</span> <span class="n">occ2</span><span class="p">]</span>

<span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pattern1</span><span class="p">,</span> <span class="n">pattern2</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_wav">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_wav</code><span class="sig-paren">(</span><em>path</em>, <em>mono=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_wav" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a .wav file as a numpy array using scipy.io.wavfile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>path</strong> : str</p>
<blockquote>
<div><p>Path to a .wav file</p>
</div></blockquote>
<p><strong>mono</strong> : bool</p>
<blockquote>
<div><p>If the provided .wav has more than one channel, it will be
converted to mono if <code class="docutils literal"><span class="pre">mono=True</span></code>. (Default value = True)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>audio_data</strong> : np.ndarray</p>
<blockquote>
<div><p>Array of audio samples, normalized to the range [-1., 1.]</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote class="last">
<div><p>Sampling rate of the audio data</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_valued_intervals">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_valued_intervals</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_valued_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import valued intervals from an annotation file. The file should
consist of three columns: Two consisting of numeric values corresponding to
start and end time of each interval and a third, also of numeric values,
corresponding to the value of each interval. This is primarily useful for
processing events which span a duration and have a numeric value, such as
piano-roll notes which have an onset, offset, and a pitch value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intervals</strong> : np.ndarray, shape=(n_events, 2)</p>
<blockquote>
<div><p>Array of event start and end times</p>
</div></blockquote>
<p><strong>values</strong> : np.ndarray, shape=(n_events,)</p>
<blockquote class="last">
<div><p>Array of values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_key">
<code class="descclassname">mir_eval.io.</code><code class="descname">load_key</code><span class="sig-paren">(</span><em>filename</em>, <em>delimiter='\\s+'</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.io.load_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Load key labels from an annotation file. The file should
consist of two string columns: One denoting the key scale degree
(semitone), and the other denoting the mode (major or minor).  The file
should contain only one row.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Path to the annotation file</p>
</div></blockquote>
<p><strong>delimiter</strong> : str</p>
<blockquote>
<div><p>Separator regular expression.
By default, lines will be split by any amount of whitespace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>key</strong> : str</p>
<blockquote class="last">
<div><p>Key label, in the form <code class="docutils literal"><span class="pre">'(key)</span> <span class="pre">(mode)'</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mir_eval.sonify">
<span id="mir-eval-sonify"></span><h3><a class="reference internal" href="#module-mir_eval.sonify" title="mir_eval.sonify"><code class="xref py py-mod docutils literal"><span class="pre">mir_eval.sonify</span></code></a><a class="headerlink" href="#module-mir_eval.sonify" title="Permalink to this headline">¶</a></h3>
<p>Methods which sonify annotations for &#8220;evaluation by ear&#8221;.
All functions return a raw signal at the specified sampling rate.</p>
<dl class="function">
<dt id="mir_eval.sonify.clicks">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">clicks</code><span class="sig-paren">(</span><em>times</em>, <em>fs</em>, <em>click=None</em>, <em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.clicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the signal &#8216;click&#8217; placed at each specified time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : np.ndarray</p>
<blockquote>
<div><p>times to place clicks, in seconds</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>desired sampling rate of the output signal</p>
</div></blockquote>
<p><strong>click</strong> : np.ndarray</p>
<blockquote>
<div><p>click signal, defaults to a 1 kHz blip</p>
</div></blockquote>
<p><strong>length</strong> : int</p>
<blockquote>
<div><p>desired number of samples in the output signal,
defaults to <code class="docutils literal"><span class="pre">times.max()*fs</span> <span class="pre">+</span> <span class="pre">click.shape[0]</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>click_signal</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Synthesized click signal</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.time_frequency">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">time_frequency</code><span class="sig-paren">(</span><em>gram</em>, <em>frequencies</em>, <em>times</em>, <em>fs</em>, <em>function=&lt;ufunc 'sin'&gt;</em>, <em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.time_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a time-frequency representation of a signal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>gram</strong> : np.ndarray</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">gram[n,</span> <span class="pre">m]</span></code> is the magnitude of <code class="docutils literal"><span class="pre">frequencies[n]</span></code>
from <code class="docutils literal"><span class="pre">times[n]</span></code> to <code class="docutils literal"><span class="pre">times[n</span> <span class="pre">+</span> <span class="pre">1]</span></code></p>
</div></blockquote>
<p><strong>frequencies</strong> : np.ndarray</p>
<blockquote>
<div><p>array of size <code class="docutils literal"><span class="pre">gram.shape[0]</span></code> denoting the frequency of
each row of gram</p>
</div></blockquote>
<p><strong>times: np.ndarray, shape=(len(chord_labels),) or (len(chord_labels), 2)</strong></p>
<blockquote>
<div><p>Either the start time of each column in the gram,
or the time interval corresponding to each column.</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>desired sampling rate of the output signal</p>
</div></blockquote>
<p><strong>function</strong> : function</p>
<blockquote>
<div><p>function to use to synthesize notes, should be 2pi-periodic</p>
</div></blockquote>
<p><strong>length</strong> : int</p>
<blockquote>
<div><p>desired number of samples in the output signal,
defaults to <code class="docutils literal"><span class="pre">times[-1]*fs</span></code></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>synthesized version of the piano roll</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.chroma">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">chroma</code><span class="sig-paren">(</span><em>chromagram</em>, <em>times</em>, <em>fs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a chromagram (semitone matrix)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chromagram</strong> : np.ndarray, shape=(12, times.shape[0])</p>
<blockquote>
<div><p>Chromagram matrix, where each row represents a semitone [C-&gt;Bb]
i.e., <code class="docutils literal"><span class="pre">chromagram[3,</span> <span class="pre">j]</span></code> is the magnitude of D# from <code class="docutils literal"><span class="pre">times[j]</span></code> to
<code class="docutils literal"><span class="pre">times[j</span> <span class="pre">+</span> <span class="pre">1]</span></code></p>
</div></blockquote>
<p><strong>times: np.ndarray, shape=(len(chord_labels),) or (len(chord_labels), 2)</strong></p>
<blockquote>
<div><p>Either the start time of each column in the chromagram,
or the time interval corresponding to each column.</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>Sampling rate to synthesize audio data at</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to pass to
<a class="reference internal" href="#mir_eval.sonify.time_frequency" title="mir_eval.sonify.time_frequency"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.sonify.time_frequency()</span></code></a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Synthesized chromagram</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.chords">
<code class="descclassname">mir_eval.sonify.</code><code class="descname">chords</code><span class="sig-paren">(</span><em>chord_labels</em>, <em>intervals</em>, <em>fs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mir_eval.sonify.chords" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesizes chord labels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chord_labels</strong> : list of str</p>
<blockquote>
<div><p>List of chord label strings.</p>
</div></blockquote>
<p><strong>intervals</strong> : np.ndarray, shape=(len(chord_labels), 2)</p>
<blockquote>
<div><p>Start and end times of each chord label</p>
</div></blockquote>
<p><strong>fs</strong> : int</p>
<blockquote>
<div><p>Sampling rate to synthesize at</p>
</div></blockquote>
<p><strong>kwargs</strong></p>
<blockquote>
<div><p>Additional keyword arguments to pass to
<a class="reference internal" href="#mir_eval.sonify.time_frequency" title="mir_eval.sonify.time_frequency"><code class="xref py py-func docutils literal"><span class="pre">mir_eval.sonify.time_frequency()</span></code></a></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Synthesized chord labels</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span>Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span>Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span>Search Page</span></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">mir_eval</span></code> Documentation</a><ul>
<li><a class="reference internal" href="#installing-mir-eval">Installing <code class="docutils literal"><span class="pre">mir_eval</span></code></a></li>
<li><a class="reference internal" href="#quickstart-using-the-evaluators">Quickstart: Using the evaluators</a></li>
<li><a class="reference internal" href="#quickstart-using-mir-eval-in-python-code">Quickstart: Using <code class="docutils literal"><span class="pre">mir_eval</span></code> in Python code</a></li>
<li><a class="reference internal" href="#mir-eval"><code class="docutils literal"><span class="pre">mir_eval</span></code></a><ul>
<li><a class="reference internal" href="#module-mir_eval.beat"><code class="docutils literal"><span class="pre">mir_eval.beat</span></code></a><ul>
<li><a class="reference internal" href="#conventions">Conventions</a></li>
<li><a class="reference internal" href="#metrics">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.chord"><code class="docutils literal"><span class="pre">mir_eval.chord</span></code></a><ul>
<li><a class="reference internal" href="#id2">Conventions</a></li>
<li><a class="reference internal" href="#id4">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.melody"><code class="docutils literal"><span class="pre">mir_eval.melody</span></code></a><ul>
<li><a class="reference internal" href="#id5">Conventions</a></li>
<li><a class="reference internal" href="#id6">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.onset"><code class="docutils literal"><span class="pre">mir_eval.onset</span></code></a><ul>
<li><a class="reference internal" href="#id9">Conventions</a></li>
<li><a class="reference internal" href="#id10">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.pattern"><code class="docutils literal"><span class="pre">mir_eval.pattern</span></code></a><ul>
<li><a class="reference internal" href="#id11">Conventions</a></li>
<li><a class="reference internal" href="#id12">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.segment"><code class="docutils literal"><span class="pre">mir_eval.segment</span></code></a><ul>
<li><a class="reference internal" href="#id13">Conventions</a></li>
<li><a class="reference internal" href="#id14">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.hierarchy"><code class="docutils literal"><span class="pre">mir_eval.hierarchy</span></code></a><ul>
<li><a class="reference internal" href="#id15">Conventions</a></li>
<li><a class="reference internal" href="#id16">Metrics</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.separation"><code class="docutils literal"><span class="pre">mir_eval.separation</span></code></a><ul>
<li><a class="reference internal" href="#id17">Conventions</a></li>
<li><a class="reference internal" href="#id18">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.tempo"><code class="docutils literal"><span class="pre">mir_eval.tempo</span></code></a><ul>
<li><a class="reference internal" href="#id20">Conventions</a></li>
<li><a class="reference internal" href="#id21">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.transcription"><code class="docutils literal"><span class="pre">mir_eval.transcription</span></code></a><ul>
<li><a class="reference internal" href="#id22">Conventions</a></li>
<li><a class="reference internal" href="#id23">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.key"><code class="docutils literal"><span class="pre">mir_eval.key</span></code></a><ul>
<li><a class="reference internal" href="#id24">Conventions</a></li>
<li><a class="reference internal" href="#id25">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.util"><code class="docutils literal"><span class="pre">mir_eval.util</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.io"><code class="docutils literal"><span class="pre">mir_eval.io</span></code></a></li>
<li><a class="reference internal" href="#module-mir_eval.sonify"><code class="docutils literal"><span class="pre">mir_eval.sonify</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">mir_eval 0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Colin Raffel et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>